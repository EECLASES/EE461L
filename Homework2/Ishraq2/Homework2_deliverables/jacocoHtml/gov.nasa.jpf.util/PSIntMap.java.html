<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PSIntMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jpf-core</a> &gt; <a href="index.source.html" class="el_package">gov.nasa.jpf.util</a> &gt; <span class="el_source">PSIntMap.java</span></div><h1>PSIntMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014, United States Government, as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All rights reserved.
 *
 * The Java Pathfinder core (jpf-core) platform is licensed under the
 * Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0. 
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */

package gov.nasa.jpf.util;

import java.io.PrintStream;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Persistent (immutable) associative array that maps integer keys to generic reference values.
 * &lt;p&gt;
 * PSIntMap is implemented as a bitwise trie which processes key bits in msb order
 * (from left to right) and has the same depth along all paths (i.e. values are only kept at the
 * terminal node level, which corresponds to the rightmost bit block in the key).
 * 
 * This particular implementation was chosen to optimize performance for dense key value domains,
 * e.g. keys that are computed from counters. More specifically, PSIntMap was designed to be a
 * suitable basis for JPF Heap implementations with their characteristic usage pattern:
 *   ..
 *   transition{ ..alloc( n),..alloc(n+1),..alloc(n+2), ..}, garbage-collection{ remove(x),remove(y),..}
 *   ..
 * 
 * The 32bit keys are broken up into 5bit blocks that represent the trie levels, each 5bit block
 * (0..31) being the index for the respective child node or value.
 * For instance, a key/value pair of 12345-&gt;'x' is stored as
 * &lt;blockquote&gt;&lt;pre&gt;
 *   level:     6    5     4     3     2     1     0
 *   key:       00.00000.00000.00000.01100.00001.11001  = 12345
 *   block-val:  0     0     0     0    12     1    25
 * 
 *       Node0 (level 2 : nodes)
 *         ... 
 *         [12] -&gt; Node1 (level 1 : nodes)
 *                   ...
 *                   [1] -&gt; Node2 (level 0 : values)
 *                            ...
 *                           [25] -&gt; 'x'
 *&lt;/pre&gt;&lt;/blockquote&gt;
 * The main benefit of using this representation is that existing maps are never modified (are
 * persistent) and hence a previous state can be restored by simply keeping the reference of
 * the respective map. The main drawback is that not only the changed value has to be stored
 * upon add/remove, but everything from the node that contains this value up to the root node.
 * 
 * This implementation partitions keys from left (msb) to right, which has the major property that
 * consecutive keys are stored in the same node, which in turn allows for efficient caching of
 * the last modified node. Keeping track of this 'stagingNode' avoids copying anything
 * but the affected node until the next staging node miss, at which point the old stagingNode
 * has to be merged. This merge only requires copying of old stagingNode parents up to the
 * level that already has been copied due to the new key insertion that caused the stagingNode miss).
 * 
 * The internal trie representation uses a protected Node type, which uses the bit block values (0..31)
 * as index into an array that stores either child node references (in case this is not a
 * terminal block), or value objects (if this is the terminal level). There are three Node
 * subtypes that get promoted upon population in the following order:
 * &lt;ul&gt;
 *  &lt;li&gt;OneNode - store only a single value/child element. Every node starts as a OneNode
 *  &lt;li&gt;BitmapNode - stores up to 31 elements (compressed)
 *  &lt;li&gt;FullNode - stores 32 elements
 * &lt;/ul&gt;
 * Removal of keys leads to symmetric demotion of node types.
 * 
 * The five major public operations for PersistentIntMaps are
 * 
 * &lt;ol&gt;
 *  &lt;li&gt;set(int key, V value) -&gt; PersistentIntMap : return a new map with an additional value 
 *  &lt;li&gt;get(int key) -&gt; V : retrieve value
 *  &lt;li&gt;remove(int key) -&gt; PersistentIntMap : return a new map without the specified key/value
 *  &lt;li&gt;removeAllSatisfying(Predicate&lt;V&gt; predicate) -&gt; PersistentIntMap : return a new map
 *                             without all values satisfying the specified predicate
 *  &lt;li&gt;process(Processor&lt;V&gt; processor) : iterate over all values with specified processor
 * &lt;/ol&gt;
 *  
 * Being a persistent data structure, the main property of PersistentIntMaps is that all
 * add/remove operations (set,remove,removeAllSatisfying) have to return new PersistenIntMap
 * instances, no destructive update is allowed. Normal usage patterns therefore look like this:
 * 
 * &lt;blockquote&gt;&lt;pre&gt;
 *   PSIntMap&lt;String&gt; map = PSIntMap&lt;String&gt;();
 *   ..
 *   map = map.set(42, &quot;fortytwo&quot;); // returns a new map
 *   ..
 *   map = map.remove(42); // returns a new map
 *   ..
 *   map = map.removeAllSatisfying( new Predicate&lt;String&gt;(){ // returns a new map
 *     public boolean isTrue (String val){ 
 *       return val.endsWith(&quot;two&quot;);
 *     });
 *     
 *   map.process( new Processor&lt;String&gt;(){
 *     public void process (String val){
 *       System.out.println(val);
 *     });
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * 
 * NOTE: bitwise tries are inherently recursive data structures, which would naturally lend
 * itself to implementations using recursive methods (over nodes). However, the recursion
 * is always bounded (finite number of key bits), and we need to keep track of the terminal
 * (value) node that was modified, which means we would have to return two values from
 * every recursion level (new current level node and new (terminal) stagingNode), thus
 * requiring additional allocation per map operation ( e.g. 'result' object to keep track
 * of transient state, as in &quot;node = node.assoc(..key, value, result)&quot;) or per recursive call
 * ( result: {node,stagingNode}, as in &quot;result = node.assoc( ..key, value)&quot;). The first solution
 * would allow to create/store a result object on the caller site, but this could compromise
 * map consistency in case of concurrent map operations. Both solutions are counter-productive
 * in a sense that PSIntMap is optimized to minimize allocation count, which is the crux of
 * persistent data structures.
 * 
 * The approach that is taken here is to manually unroll the recursion by means of explicit
 * operand stacks, which leads to methods with large number of local variables (to avoid
 * array allocation) and large switch statements to set respective fields. The resulting
 * programming style should only be acceptable for critical runtime optimizations.
 */ 

public class PSIntMap &lt;V&gt; implements Iterable&lt;V&gt; {

  //--- auxiliary types
  
  /**
   * Abstract root class for all node types. This type needs to be internal, no instances
   * are allowed to be visible outside the PersistentIntMap class hierarchy in order to guarantee
   * invariant data.
   * 
   * NOTE - since this is an internal type, we forego a lot of argument range checks in
   * the Node subclasses, assuming that all internal use has been tested and bugs will not
   * cause silent corruption of node data but will lead to follow-on exceptions such as
   * ArrayIndexOutOfBounds etc.
   */
<span class="fc" id="L144">  protected abstract static class Node&lt;E&gt; {</span>
    
    abstract E getElementAtLevelIndex (int i);
    
    abstract int getNumberOfElements();
    abstract E getElementAtStorageIndex (int i);
    
    abstract int storageToLevelIndex (int i);
    
    //--- those clone
    abstract Node cloneWithAdded (int idx, E e);
    abstract Node cloneWithReplaced (int idx, E e);
    abstract Node cloneWithRemoved (int idx);
    abstract Node removeAllSatisfying (Predicate&lt;E&gt; pred);
    
    //--- no clone
    abstract void set (int idx, E e);
    abstract void process (int level, Node&lt;E&gt; targetNode, Node&lt;E&gt; stagingNode, Processor&lt;E&gt; p);
    
    boolean isEmptyNode(){
<span class="fc" id="L164">      return false;</span>
    }
    
    //--- debugging
    void printIndentOn (PrintStream ps, int level) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">      for (int i=0; i&lt;level; i++) {</span>
<span class="fc" id="L170">        ps.print(&quot;    &quot;);</span>
      }
<span class="fc" id="L172">    }</span>
    
    void printNodeInfoOn (PrintStream ps, Node targetNode, Node stagingNode) {
<span class="fc" id="L175">      String clsName = getClass().getSimpleName();</span>
<span class="fc" id="L176">      int idx = clsName.indexOf('$');</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">      if (idx &gt; 0) {</span>
<span class="nc" id="L178">        clsName = clsName.substring(idx+1);</span>
      }
<span class="fc" id="L180">      ps.print(clsName);</span>
      
<span class="fc bfc" id="L182" title="All 2 branches covered.">      if (this == targetNode){</span>
<span class="fc" id="L183">        ps.print( &quot; (target)&quot;);</span>
      }
<span class="fc" id="L185">    }</span>
    
    abstract void printOn(PrintStream ps, int level, Node targetNode, Node stagingNode);
  }
  
  /**
   * Node that has only one element and hence does not need an array.
   * If a new element is added, this OneNode gets promoted into a BitmapNode
   */
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">  protected static class OneNode&lt;E&gt; extends Node&lt;E&gt; {</span>
    E e;
    int idx;
    
<span class="fc" id="L198">    OneNode (int idx, E e){</span>
<span class="fc" id="L199">      this.idx = idx;</span>
<span class="fc" id="L200">      this.e = e;</span>
<span class="fc" id="L201">    }</span>

    @Override
    int getNumberOfElements(){
<span class="fc" id="L205">      return 1;</span>
    }
    
    @Override
    E getElementAtStorageIndex (int i){
<span class="nc bnc" id="L210" title="All 4 branches missed.">      assert i == 0;</span>
<span class="nc" id="L211">      return e;</span>
    }
    
    @Override
    E getElementAtLevelIndex(int i) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (i == idx){</span>
<span class="fc" id="L217">        return e;</span>
      } else {
<span class="fc" id="L219">        return null;</span>
      }
    }

    @Override
    int storageToLevelIndex (int i){
<span class="nc bnc" id="L225" title="All 2 branches missed.">      if (i == 0){</span>
<span class="nc" id="L226">        return idx;</span>
      }
<span class="nc" id="L228">      return -1;</span>
    }
    
    /**
     * this assumes the index is not set 
     */
    @Override
    Node cloneWithAdded(int i, E newElement) {
<span class="pc bpc" id="L236" title="2 of 4 branches missed.">      assert i != idx;</span>
      
<span class="fc" id="L238">      Object[] a = new Object[2];</span>
      
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">      if (i &lt; idx){</span>
<span class="nc" id="L241">        a[0] = newElement;</span>
<span class="nc" id="L242">        a[1] = e;</span>
      } else {
<span class="fc" id="L244">        a[0] = e;</span>
<span class="fc" id="L245">        a[1] = newElement;</span>
      }
<span class="fc" id="L247">      int bitmap = (1 &lt;&lt; idx) | (1 &lt;&lt; i);</span>
      
<span class="fc" id="L249">      return new BitmapNode(bitmap, a);</span>
    }

    /**
     * this assumes the index is set 
     */
    @Override
    Node cloneWithReplaced(int i, E e) {
<span class="pc bpc" id="L257" title="2 of 4 branches missed.">      assert i == idx;</span>
<span class="fc" id="L258">      return new OneNode( i, e);</span>
    }

    /**
     * this assumes the index is set 
     */
    @Override
    Node cloneWithRemoved(int i){
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">      assert (i == idx);</span>
<span class="fc" id="L267">      return null;</span>
    }
    
    @Override
    Node removeAllSatisfying (Predicate&lt;E&gt; pred){
<span class="fc bfc" id="L272" title="All 2 branches covered.">      if (pred.isTrue(e)){</span>
<span class="fc" id="L273">        return null;</span>
      } else {
<span class="fc" id="L275">        return this;</span>
      }
    }
    
    @Override
    void set (int i, E e){
<span class="nc bnc" id="L281" title="All 4 branches missed.">      assert i == idx;</span>
<span class="nc" id="L282">      this.e = e;</span>
<span class="nc" id="L283">    }</span>
    
    @Override
    boolean isEmptyNode(){
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">      return idx == 0;</span>
    }
    
    @Override
    void process (int level, Node&lt;E&gt; targetNode, Node&lt;E&gt; stagingNode, Processor&lt;E&gt; p){
<span class="fc bfc" id="L292" title="All 2 branches covered.">      if (level == 0){</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (this == targetNode){</span>
<span class="nc" id="L294">          stagingNode.process( 0, null, null, p);</span>
        } else {
<span class="fc" id="L296">          p.process(e);</span>
        }
      } else {
<span class="fc" id="L299">        ((Node)e).process( level-1, targetNode, stagingNode, p);</span>
      }
<span class="fc" id="L301">    }</span>
    
    @Override
	public void printOn (PrintStream ps, int depth, Node targetNode, Node stagingNode) {
<span class="fc" id="L305">      printIndentOn(ps, depth);</span>
<span class="fc" id="L306">      ps.printf(&quot;%2d: &quot;, idx);</span>

<span class="fc bfc" id="L308" title="All 2 branches covered.">      if (e instanceof Node) {</span>
<span class="fc" id="L309">        Node&lt;E&gt; n = (Node&lt;E&gt;) e;</span>
<span class="fc" id="L310">        n.printNodeInfoOn(ps, targetNode, stagingNode);</span>
<span class="fc" id="L311">        ps.println();</span>
<span class="fc" id="L312">        n.printOn(ps, depth+1, targetNode, stagingNode);</span>
<span class="fc" id="L313">      } else {</span>
<span class="fc" id="L314">        ps.print(&quot;value=&quot;);</span>
<span class="fc" id="L315">        ps.println(e);</span>
      }
<span class="fc" id="L317">    }</span>

  }
  
  /**
   * A node that holds between 2 and 31 elements.
   * 
   * We use bitmap based element array compaction - the corresponding bit block of the key
   * [0..31] is used as an index into a bitmap. The elements are stored in a dense
   * array at indices corresponding to the number of set bitmap bits to the right of the
   * respective index in the bitmap, e.g. for
   * 
   * &lt;blockquote&gt;&lt;pre&gt; 
   *   key = 289 =  0b01001.00001, shift = 5, assuming node already contains key 97 = 0b00011.00001 =&gt;
   *     idx = (key &gt;&gt;&gt; shift) &amp; 0x1f = 0b01001 = 9
   *     bitmap =  1000001000  : bit 9 from key 289 (0b01001.), bit 3 from key 97 (0b00011.)
   *     node element index for key 289 (level index 9) = 1 (one set bit to the right of bit 9)
   * &lt;/pre&gt;&lt;/blockquote&gt;
   * 
   * While storage index computation seems complicated and expensive, there are efficient algorithms to
   * count leading/trailing bits by means of binary operations and minimal branching, which is
   * suitable for JIT compilation (see http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup)
   * 
   * &lt;p&gt;
   * If the bit count of a BitmapNode is 2 and an element is removed, this gets demoted into q OneNode.
   * If the bit count of a BitmapNode is 31 and an element is added, this gets promoted into a FullNode
   */
  protected static class BitmapNode&lt;E&gt; extends Node&lt;E&gt; {
    final E[] elements;
    final int bitmap;
    
<span class="fc" id="L348">    BitmapNode (int idx, E e, E e0){</span>
<span class="fc" id="L349">      bitmap = (1 &lt;&lt; idx) | 1;</span>
      
<span class="fc" id="L351">      elements = (E[]) new Object[2];</span>
<span class="fc" id="L352">      elements[0] = e0;</span>
<span class="fc" id="L353">      elements[1] = e;</span>
<span class="fc" id="L354">    }</span>
    
<span class="fc" id="L356">    BitmapNode (int bitmap, E[] elements){</span>
<span class="fc" id="L357">      this.bitmap = bitmap;</span>
<span class="fc" id="L358">      this.elements = elements;</span>
<span class="fc" id="L359">    }</span>
    
    @Override
    int getNumberOfElements(){
<span class="fc" id="L363">      return elements.length;</span>
    }
    
    @Override
    E getElementAtStorageIndex (int i){
<span class="fc" id="L368">      return elements[i];</span>
    }
    
    @Override
    E getElementAtLevelIndex (int i) {
<span class="fc" id="L373">      int bit = 1 &lt;&lt; i;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">      if ((bitmap &amp; bit) != 0) {</span>
<span class="fc" id="L375">        int idx = Integer.bitCount( bitmap &amp; (bit-1));</span>
<span class="fc" id="L376">        return elements[idx];</span>
      } else {
<span class="fc" id="L378">        return null;</span>
      }
    }

    /**
     * get the position of the (n+1)'th set bit in bitmap
     */
    @Override
    int storageToLevelIndex (int n){
<span class="fc" id="L387">      int v = bitmap;</span>
      /**/
<span class="fc bfc" id="L389" title="All 31 branches covered.">      switch (n){</span>
<span class="fc" id="L390">        case 30: v &amp;= v-1;</span>
<span class="fc" id="L391">        case 29: v &amp;= v-1;</span>
<span class="fc" id="L392">        case 28: v &amp;= v-1;</span>
<span class="fc" id="L393">        case 27: v &amp;= v-1;</span>
<span class="fc" id="L394">        case 26: v &amp;= v-1;</span>
<span class="fc" id="L395">        case 25: v &amp;= v-1;</span>
<span class="fc" id="L396">        case 24: v &amp;= v-1;</span>
<span class="fc" id="L397">        case 23: v &amp;= v-1;</span>
<span class="fc" id="L398">        case 22: v &amp;= v-1;</span>
<span class="fc" id="L399">        case 21: v &amp;= v-1;</span>
<span class="fc" id="L400">        case 20: v &amp;= v-1;</span>
<span class="fc" id="L401">        case 19: v &amp;= v-1;</span>
<span class="fc" id="L402">        case 18: v &amp;= v-1;</span>
<span class="fc" id="L403">        case 17: v &amp;= v-1;</span>
<span class="fc" id="L404">        case 16: v &amp;= v-1;</span>
<span class="fc" id="L405">        case 15: v &amp;= v-1;</span>
<span class="fc" id="L406">        case 14: v &amp;= v-1;</span>
<span class="fc" id="L407">        case 13: v &amp;= v-1;</span>
<span class="fc" id="L408">        case 12: v &amp;= v-1;</span>
<span class="fc" id="L409">        case 11: v &amp;= v-1;</span>
<span class="fc" id="L410">        case 10: v &amp;= v-1;</span>
<span class="fc" id="L411">        case 9: v &amp;= v-1;</span>
<span class="fc" id="L412">        case 8: v &amp;= v-1;</span>
<span class="fc" id="L413">        case 7: v &amp;= v-1;</span>
<span class="fc" id="L414">        case 6: v &amp;= v-1;</span>
<span class="fc" id="L415">        case 5: v &amp;= v-1;</span>
<span class="fc" id="L416">        case 4: v &amp;= v-1;</span>
<span class="fc" id="L417">        case 3: v &amp;= v-1;</span>
<span class="fc" id="L418">        case 2: v &amp;= v-1;</span>
<span class="fc" id="L419">        case 1: v &amp;= v-1;</span>
      }
      /**/
      
      /**
      for (int i=n; i&gt;0; i--){
        v &amp;= v-1; // remove n-1 least significant bits
      }
      **/
      
<span class="fc" id="L429">      v = v &amp; ~(v-1); // reduce to the least significant bit</span>
<span class="fc" id="L430">      return TrailingMultiplyDeBruijnBitPosition[((v &amp; -v) * 0x077CB531) &gt;&gt;&gt; 27];</span>
    }
    
    @Override
    Node cloneWithAdded(int i, E e) {
<span class="fc" id="L435">      int bit = 1 &lt;&lt; i;</span>
<span class="fc" id="L436">      int idx = Integer.bitCount( bitmap &amp; (bit -1));</span>
      
<span class="fc bfc" id="L438" title="All 2 branches covered.">      if (elements.length == 31){</span>
<span class="fc" id="L439">        Object[] a = new Object[32];</span>

<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (idx &gt; 0) {</span>
<span class="fc" id="L442">          System.arraycopy(elements, 0, a, 0, idx);</span>
        }
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (idx &lt; 31) {</span>
<span class="nc" id="L445">          System.arraycopy(elements, idx, a, idx + 1, 31 - idx);</span>
        }
<span class="fc" id="L447">        a[idx] = e;</span>
<span class="fc" id="L448">        return new FullNode(a);</span>
        
      } else {
<span class="fc" id="L451">        int n = elements.length;</span>
<span class="fc" id="L452">        Object[] a = new Object[n + 1];</span>

<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (idx &gt; 0) {</span>
<span class="fc" id="L455">          System.arraycopy(elements, 0, a, 0, idx);</span>
        }

<span class="fc" id="L458">        a[idx] = e;</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (n &gt; idx) {</span>
<span class="fc" id="L461">          System.arraycopy(elements, idx, a, idx + 1, (n - idx));</span>
        }
      
<span class="fc" id="L464">        return new BitmapNode( bitmap | bit, a);</span>
      }
    }

    @Override
    Node cloneWithReplaced(int i, E e) {
<span class="fc" id="L470">      int idx = Integer.bitCount( bitmap &amp; ((1&lt;&lt;i) -1));</span>
      
<span class="fc" id="L472">      E[] a = elements.clone();</span>
<span class="fc" id="L473">      a[idx] = e;</span>
      
<span class="fc" id="L475">      return new BitmapNode( bitmap, a);</span>
    }
    
    @Override
    Node cloneWithRemoved(int i){
<span class="fc" id="L480">      int bit = (1&lt;&lt;i);</span>
<span class="fc" id="L481">      int idx = Integer.bitCount( bitmap &amp; (bit-1));</span>
<span class="fc" id="L482">      int n = elements.length;</span>
      
<span class="fc bfc" id="L484" title="All 2 branches covered.">      if (n == 2){</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        E e = (idx == 0) ? elements[1] : elements[0]; // the remaining value</span>
<span class="fc" id="L486">        int i0 = Integer.numberOfTrailingZeros(bitmap ^ bit);</span>
<span class="fc" id="L487">        return new OneNode( i0, e);</span>
        
      } else {
<span class="fc" id="L490">        Object[] a = new Object[n - 1];</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (idx &gt; 0) {</span>
<span class="fc" id="L492">          System.arraycopy(elements, 0, a, 0, idx);</span>
        }
<span class="fc" id="L494">        n--;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (n &gt; idx) {</span>
<span class="nc" id="L496">          System.arraycopy(elements, idx + 1, a, idx, (n - idx));</span>
        }
<span class="fc" id="L498">        return new BitmapNode(bitmap ^ bit, a);</span>
      }
    }
    
    @Override
    Node removeAllSatisfying (Predicate&lt;E&gt; pred){
<span class="fc" id="L504">      int newBitmap = bitmap;</span>
<span class="fc" id="L505">      int len = elements.length;</span>
<span class="fc" id="L506">      int newLen = len;</span>
<span class="fc" id="L507">      E[] elem = elements;</span>
<span class="fc" id="L508">      int removed = 0;</span>
      
<span class="fc bfc" id="L510" title="All 2 branches covered.">      for (int i=0, bit=1; i&lt;len; i++, bit&lt;&lt;=1){</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">        while ((newBitmap &amp; bit) == 0){</span>
<span class="fc" id="L512">          bit &lt;&lt;= 1;</span>
        }
        
<span class="fc bfc" id="L515" title="All 2 branches covered.">        if (pred.isTrue(elem[i])){</span>
<span class="fc" id="L516">          newBitmap ^= bit;</span>
<span class="fc" id="L517">          newLen--;</span>
<span class="fc" id="L518">          removed |= (1 &lt;&lt; i);</span>
        } 
      }
      
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">      if (newLen == 0){ // nothing left</span>
<span class="nc" id="L523">        return null;</span>
        
<span class="fc bfc" id="L525" title="All 2 branches covered.">      } else if (newLen == len){ // nothing removed</span>
<span class="fc" id="L526">        return this;</span>
        
<span class="fc bfc" id="L528" title="All 2 branches covered.">      } else if (newLen == 1) { // just one value left - reduce to OneNode</span>
<span class="fc" id="L529">        int i = Integer.bitCount( bitmap &amp; (newBitmap -1));</span>
<span class="fc" id="L530">        int idx = Integer.numberOfTrailingZeros(newBitmap);</span>
<span class="fc" id="L531">        return new OneNode&lt;E&gt;( idx, elem[i]);</span>
        
      } else { // some values removed - reduced BitmapNode
<span class="fc" id="L534">        E[] newElements = (E[]) new Object[newLen];</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (int i=0, j=0; j&lt;newLen; i++){</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">          if ((removed &amp; (1&lt;&lt;i)) == 0){</span>
<span class="fc" id="L537">            newElements[j++] = elem[i];</span>
          }
        }
<span class="fc" id="L540">        return new BitmapNode( newBitmap, newElements);</span>
      }
    }

    
    @Override
    void set (int i, E e){
<span class="fc" id="L547">      int idx = Integer.bitCount( bitmap &amp; ((1&lt;&lt;i) -1));</span>
<span class="fc" id="L548">      elements[idx] = e;</span>
<span class="fc" id="L549">    }</span>
    
    @Override
    void process (int level, Node&lt;E&gt; targetNode, Node&lt;E&gt; stagingNode, Processor&lt;E&gt; p){
<span class="fc bfc" id="L553" title="All 2 branches covered.">      if (level == 0){</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (this == targetNode){</span>
<span class="fc" id="L555">          stagingNode.process(0, null, null, p);</span>
        } else {
<span class="fc bfc" id="L557" title="All 2 branches covered.">          for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L558">            p.process(elements[i]);</span>
          }
        }
      } else {
<span class="fc bfc" id="L562" title="All 2 branches covered.">        for (int i=0; i&lt;elements.length; i++){</span>
<span class="fc" id="L563">          ((Node)elements[i]).process(level-1, targetNode, stagingNode, p);</span>
        }        
      }
<span class="fc" id="L566">    }</span>
    
    @Override
	void printOn (PrintStream ps, int depth, Node targetNode, Node stagingNode) {
<span class="fc" id="L570">      int j=0;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">      for (int i=0; i&lt;32; i++) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if ((bitmap &amp; (1&lt;&lt;i)) != 0) {</span>
<span class="fc" id="L573">          printIndentOn(ps, depth);</span>
<span class="fc" id="L574">          ps.printf(&quot;%2d: &quot;, i);</span>
          
<span class="fc" id="L576">          E e = elements[j++];</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">          if (e instanceof Node) {</span>
<span class="fc" id="L578">            Node&lt;E&gt; n = (Node&lt;E&gt;)e;</span>
<span class="fc" id="L579">            n.printNodeInfoOn(ps, targetNode, stagingNode);</span>
<span class="fc" id="L580">            ps.println();</span>
<span class="fc" id="L581">            n.printOn(ps, depth+1, targetNode, stagingNode);</span>
<span class="fc" id="L582">          } else {</span>
<span class="fc" id="L583">            ps.print(&quot;value=&quot;);</span>
<span class="fc" id="L584">            ps.println(e);</span>
          }
        }
      }
<span class="fc" id="L588">    }</span>

  }

  /**
   * newElements node with 32 elements, for which we don't need newElements bitmap.
   * No element can be added since this means we just promote an existing element
   * If an element is removed, this FullNode gets demoted int newElements BitmapNode
   */
  protected static class FullNode&lt;E&gt; extends Node&lt;E&gt; {
    final E[] elements;

<span class="fc" id="L600">    FullNode (E[] elements){</span>
<span class="fc" id="L601">      this.elements = elements;</span>
<span class="fc" id="L602">    }</span>
    
    @Override
    int getNumberOfElements(){
<span class="fc" id="L606">      return 32;</span>
    }
    
    @Override
    E getElementAtStorageIndex (int i){
<span class="fc" id="L611">      return elements[i];</span>
    }
    
    @Override
    E getElementAtLevelIndex (int i) {
<span class="fc" id="L616">      return elements[i];</span>
    }

    @Override
    int storageToLevelIndex (int i){
<span class="fc" id="L621">      return i;</span>
    }

    
    @Override
    Node cloneWithAdded (int idx, E e){
<span class="nc" id="L627">      throw new RuntimeException(&quot;can't add a new element to a FullNode&quot;);</span>
    }
    
    @Override
    Node cloneWithReplaced (int idx, E e){
<span class="fc" id="L632">      E[] newElements = elements.clone();</span>
<span class="fc" id="L633">      newElements[idx] = e;</span>
<span class="fc" id="L634">      return new FullNode(newElements);</span>
    }
    
    @Override
    Node cloneWithRemoved(int idx){
<span class="fc" id="L639">      Object[] a = new Object[31];</span>
<span class="fc" id="L640">      int bitmap = 0xffffffff ^ (1 &lt;&lt; idx);</span>
      
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">      if (idx &gt; 0){</span>
<span class="fc" id="L643">        System.arraycopy(elements, 0, a, 0, idx);</span>
      }
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">      if (idx &lt; 31){</span>
<span class="nc" id="L646">        System.arraycopy(elements, idx+1, a, idx, 31-idx);</span>
      }
      
<span class="fc" id="L649">      return new BitmapNode( bitmap, a);</span>
    }
    
    @Override
    Node removeAllSatisfying (Predicate&lt;E&gt; pred){
<span class="fc" id="L654">      int newBitmap = 0xffffffff;</span>
<span class="fc" id="L655">      int newLen = 32;</span>
<span class="fc" id="L656">      E[] elem = elements;</span>
<span class="fc" id="L657">      int removed = 0;</span>
      
<span class="fc bfc" id="L659" title="All 2 branches covered.">      for (int i=0, bit=1; i&lt;32; i++, bit&lt;&lt;=1){</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (pred.isTrue(elem[i])){</span>
<span class="fc" id="L661">          newBitmap ^= bit;</span>
<span class="fc" id="L662">          newLen--;</span>
<span class="fc" id="L663">          removed |= (1 &lt;&lt; i);</span>
        } 
      }
      
<span class="fc bfc" id="L667" title="All 2 branches covered.">      if (newLen == 0){ // nothing left</span>
<span class="fc" id="L668">        return null;</span>
        
<span class="fc bfc" id="L670" title="All 2 branches covered.">      } else if (newLen == 32){ // nothing removed</span>
<span class="fc" id="L671">        return this;</span>
        
<span class="fc bfc" id="L673" title="All 2 branches covered.">      } else if (newLen == 1) { // just one value left - reduce to OneNode</span>
<span class="fc" id="L674">        int idx = Integer.numberOfTrailingZeros(newBitmap);  </span>
<span class="fc" id="L675">        return new OneNode&lt;E&gt;( idx, elem[idx]);</span>
        
      } else { // some values removed - reduced BitmapNode
<span class="fc" id="L678">        E[] newElements = (E[]) new Object[newLen];</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        for (int i=0, j=0; j&lt;newLen; i++){</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">          if ((removed &amp; (1&lt;&lt;i)) == 0){</span>
<span class="fc" id="L681">            newElements[j++] = elem[i];</span>
          }
        }
<span class="fc" id="L684">        return new BitmapNode( newBitmap, newElements);</span>
      }
    }
    
    @Override
    void set (int i, E e){
<span class="fc" id="L690">      elements[i] = e;</span>
<span class="fc" id="L691">    }</span>
    
    @Override
    void process (int level, Node&lt;E&gt; targetNode, Node&lt;E&gt; stagingNode, Processor&lt;E&gt; p){
<span class="nc bnc" id="L695" title="All 2 branches missed.">      if (level == 0){</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (this == targetNode){</span>
<span class="nc" id="L697">          stagingNode.process(0, null, null, p);</span>
        } else {
<span class="nc bnc" id="L699" title="All 2 branches missed.">          for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="nc" id="L700">            p.process(elements[i]);</span>
          }
        }
      } else {
<span class="nc bnc" id="L704" title="All 2 branches missed.">        for (int i=0; i&lt;elements.length; i++){</span>
<span class="nc" id="L705">          ((Node)elements[i]).process(level-1, targetNode, stagingNode, p);</span>
        }        
      }
<span class="nc" id="L708">    }</span>
    
    @Override
	void printOn (PrintStream ps, int depth, Node targetNode, Node stagingNode) {    
<span class="nc bnc" id="L712" title="All 2 branches missed.">      for (int i=0; i&lt;32; i++) {</span>
<span class="nc" id="L713">        printIndentOn(ps, depth);</span>
<span class="nc" id="L714">        ps.printf(&quot;%2d: &quot;, i);</span>

<span class="nc" id="L716">        E e = elements[i];</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (e instanceof Node) {</span>
<span class="nc" id="L718">          Node&lt;E&gt; n = (Node&lt;E&gt;) e;</span>
<span class="nc" id="L719">          n.printNodeInfoOn(ps, targetNode, stagingNode);</span>
<span class="nc" id="L720">          ps.println();</span>
<span class="nc" id="L721">          n.printOn(ps, depth+1, targetNode, stagingNode);</span>
<span class="nc" id="L722">        } else {</span>
<span class="nc" id="L723">          ps.print(&quot;value=&quot;);</span>
<span class="nc" id="L724">          ps.println(e);</span>
        }
      }
<span class="nc" id="L727">    }</span>
  }

  @Override
@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
  public Iterator&lt;V&gt; iterator(){
<span class="fc" id="L733">    return new ValueIterator();</span>
  }
  
  /**
   * this is less efficient than using map.process(processor), but required to use PSIntMaps in lieu of ordinary containers
   * Since PSIntMaps are bounded recursive data structures, we have to model newElements stack explicitly, but at least we know it is
   * not exceeding newElements depth of 6 (5 bit index blocks)
   * 
   * Note - there are no empty nodes. Each one has at least newElements single child node or value
   */
  protected class ValueIterator implements Iterator&lt;V&gt; {

    Node node;
    int nodeIdx, maxNodeIdx;
    
    Node[] parentNodeStack;
    int[] parentIdxStack;
    int top;
    int nVisited, nTotal;
    
    
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L755">    public ValueIterator (){</span>
<span class="fc" id="L756">      node = PSIntMap.this.rootNode;</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">      if (node != null) {</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (node == PSIntMap.this.targetNode){</span>
<span class="nc" id="L759">          node = PSIntMap.this.stagingNode;</span>
        }
        
<span class="fc" id="L762">        maxNodeIdx = node.getNumberOfElements();</span>
        
        // nodeIdx = 0;
        // nVisited = 0;
        // top = 0;
        
<span class="fc" id="L768">        int depth = PSIntMap.this.rootLevel;</span>
<span class="fc" id="L769">        parentNodeStack = new Node[depth];</span>
<span class="fc" id="L770">        parentIdxStack = new int[depth];</span>
            
<span class="fc" id="L772">        nTotal = PSIntMap.this.size;</span>
      }
<span class="fc" id="L774">    }</span>
    
    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L778" title="All 2 branches covered.">      return nVisited &lt; nTotal;</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public V next() {
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">      if (nVisited &gt;= nTotal) {</span>
<span class="nc" id="L785">        throw new NoSuchElementException();</span>
      }
      
<span class="fc" id="L788">      int idx = nodeIdx;</span>
<span class="fc" id="L789">      Object nv = node.getElementAtStorageIndex( idx);</span>
      
      //--- descend
<span class="fc bfc" id="L792" title="All 2 branches covered.">      while (top &lt; PSIntMap.this.rootLevel) {</span>
<span class="fc" id="L793">        parentNodeStack[top] = node; // push current node on stack</span>
<span class="fc" id="L794">        parentIdxStack[top] = idx;</span>
<span class="fc" id="L795">        top++;</span>
        
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (nv == PSIntMap.this.targetNode){</span>
<span class="fc" id="L798">          node = PSIntMap.this.stagingNode;</span>
        } else {        
<span class="fc" id="L800">          node = (Node)nv;</span>
        }
        
<span class="fc" id="L803">        idx = nodeIdx = 0;</span>
<span class="fc" id="L804">        maxNodeIdx = node.getNumberOfElements();</span>
        
<span class="fc" id="L806">        nv = node.getElementAtStorageIndex(0);</span>
      }
      
      //--- newElements value, finally
<span class="fc" id="L810">      nVisited++;</span>
<span class="fc" id="L811">      idx++;</span>

<span class="fc bfc" id="L813" title="All 2 branches covered.">      if (idx == maxNodeIdx) { // done, no more child nodes/values for this node</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        while (top &gt; 0) { // go up</span>
<span class="fc" id="L815">          top--;</span>
<span class="fc" id="L816">          node = parentNodeStack[top];</span>
<span class="fc" id="L817">          nodeIdx = parentIdxStack[top] + 1;</span>
<span class="fc" id="L818">          maxNodeIdx = node.getNumberOfElements();</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">          if (nodeIdx &lt; maxNodeIdx) break;</span>
        }
      } else {
<span class="fc" id="L822">        nodeIdx = idx;</span>
      }

      //assert (nVisited == nTotal) || (nodeIdx &lt; maxNodeIdx);
<span class="fc" id="L826">      return (V) nv;</span>
    }

    @Override
    public void remove() {
<span class="nc" id="L831">      throw new UnsupportedOperationException(&quot;PersistentIntMap iterators don't support removal&quot;);</span>
    }
    
  }

  
  //--- auxiliary data and functions
  
  static final int BASE_MASK = ~0x1f;
  
<span class="fc" id="L841">  static final int TrailingMultiplyDeBruijnBitPosition[] = {</span>
    0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
    31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
  };
  
  static int getNumberOfTrailingZeros (int v){
<span class="nc" id="L847">    return TrailingMultiplyDeBruijnBitPosition[((v &amp; -v) * 0x077CB531) &gt;&gt;&gt; 27];</span>
  }
  
  
  // the values are the respective block levels
<span class="fc" id="L852">  static final int LeadingMultiplyDeBruijnBitPosition[] = {</span>
    0, 1, 0, 2, 2, 4, 0, 5, 2, 2, 3, 3, 4, 5, 0, 6,
    1, 2, 4, 5, 3, 3, 4, 1, 3, 5, 4, 1, 5, 1, 0, 6
  };
  
  /**
   * get the start level [0..7] for the highest bit index (bit block). This is essentially counting the number of leading zero bits,
   * which we can derive from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup
   */
  static int getStartLevel (int v){
<span class="fc" id="L862">    v |= v &gt;&gt;&gt; 1;</span>
<span class="fc" id="L863">    v |= v &gt;&gt;&gt; 2;</span>
<span class="fc" id="L864">    v |= v &gt;&gt;&gt; 4;</span>
<span class="fc" id="L865">    v |= v &gt;&gt;&gt; 8;</span>
<span class="fc" id="L866">    v |= v &gt;&gt;&gt; 16;</span>

<span class="fc" id="L868">    return LeadingMultiplyDeBruijnBitPosition[(v * 0x07C4ACDD) &gt;&gt;&gt; 27];</span>
  }
  
  //--- instance data
  
  final protected int size;       // number of values in this map
  final protected int rootLevel;  // bit block level of the root node (highest non-0 bit block of all keys in map)
  final protected Node rootNode;  // topmost node of trie
  
  /*
   * the following fields are used to cache consecutive key operations with the goal of avoiding
   * path copies from the modified value node all the way up to the root node. As long as the same value
   * node is modified (hence msb key block traversal) we just need to keep track which position in the
   * trie the stagingNode refers to (stagingNodeMask), and only have to create a new stagingNode with the
   * updated values. Once we have a key operation that refers to a different value node position (staging miss),
   * we merge the old stagingNode back into the trie. If we do this after inserting the new key, only
   * nodes from the old stagingNode parent up to the first node that is on the new key path have to be copied,
   * the merge node (on the new stagingNode path) can be safely modified since it has only been created during
   * the ongoing map operation. Example:
   *                                          key    value
   * last mod key/value (old stagingNode) : a.c.e -&gt; Y    =&gt; stagingNodeMask = a.c.FF
   * new key/value (new stagingNode)      : a.b.d -&gt; X
   * 
   *                            a
   *                    n0: [...n1...]            root node (level 2)
   *                           /
   *                 b    c   /
   *          n1:  [.n2...n3.]                    
   *                /       \
   *           d   /         \                                                  e
   *    n2:  [.X..]      n3:  [.....]             value nodes (level 0)     [...Y...]
   *      new stagingNode       old targetNode  &lt;-------------------------- old stagingNode
   *    (= new targetNode)
   * 
   * In this case, the sequence of operations is as follows:
   * &lt;ol&gt;
   *   &lt;li&gt; insert new key/value pair (a.b.d)-&gt;X into the trie, which is a stagingNode miss since
   *        stagingNodeMasks are different (a.b.FF != a.c.FF). This leads to copied/new nodes n2,n1,n0
   *   &lt;li&gt; check if old stagingNode differs from targetNode (had several consecutive modifications), if
   *        targetNode != stagingNode then merge old stagingNode &lt;em&gt;after&lt;/em&gt; n2,n1,n0 creation
   *   &lt;li&gt; since n1 is already a new node that is not shared with any prior version of this map,
   *        its [c] element can be simply set to the old stagingNode, i.e. the merge does not require
   *        any additional allocation. Note that n1 has to contain a [c] element since we always link
   *        new stagingNodes into the trie upon creation. This means the number of elements in n1
   *        (and hence the node type) does not change, i.e. setting the new [c] element involves
   *        just a single AASTORE instruction
   *   &lt;li&gt; set stagingNode = targetNode = n2
   * &lt;/ol&gt;
   */
  
  final protected Node&lt;V&gt; stagingNode; // last modified value node (not linked into the trie upon subsequent modification)
  final protected int stagingNodeMask; // key mask for stagingNode (key | 0x1f)
  final protected Node targetNode;     // original stagingNode state that is linked into the trie
  
  /**
   * the only public constructor
   */
<span class="fc" id="L925">  public PSIntMap(){</span>
<span class="fc" id="L926">    this.size = 0;</span>
<span class="fc" id="L927">    this.rootLevel = 0;</span>
<span class="fc" id="L928">    this.rootNode = null;</span>
<span class="fc" id="L929">    this.targetNode = null;</span>
<span class="fc" id="L930">    this.stagingNode = null;</span>
<span class="fc" id="L931">    this.stagingNodeMask = 0;</span>
<span class="fc" id="L932">  }</span>
  
<span class="fc" id="L934">  protected PSIntMap (int size, int rootLevel, Node rootNode, Node&lt;V&gt; stagingNode, Node&lt;V&gt; targetNode, int stagingNodeMask){</span>
<span class="fc" id="L935">    this.size = size;</span>
<span class="fc" id="L936">    this.rootLevel = rootLevel;</span>
<span class="fc" id="L937">    this.rootNode = rootNode;</span>
<span class="fc" id="L938">    this.stagingNode = stagingNode;</span>
<span class="fc" id="L939">    this.targetNode = targetNode;</span>
<span class="fc" id="L940">    this.stagingNodeMask = stagingNodeMask;</span>
<span class="fc" id="L941">  }</span>
  
  //--- public API
  
  public int size(){
<span class="fc" id="L946">    return size;</span>
  }
  
  public V get (int key){
<span class="fc bfc" id="L950" title="All 2 branches covered.">    if (stagingNodeMask == (key | 0x1f)){</span>
<span class="fc" id="L951">      int idx = key &amp; 0x1f;</span>
<span class="fc" id="L952">      return stagingNode.getElementAtLevelIndex(idx);</span>
      
    } else {
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">      if (rootNode == null) return null;</span>
      
<span class="fc" id="L957">      int l = getStartLevel(key);</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">      if (l &gt; rootLevel) return null;</span>
      
<span class="fc" id="L960">      Node&lt;Node&gt; n = rootNode;</span>
      
<span class="pc bpc" id="L962" title="5 of 8 branches missed.">      switch (rootLevel){</span>
        case 6: 
<span class="nc" id="L964">          n = n.getElementAtLevelIndex( key &gt;&gt;&gt; 30);</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">          if (n == null) return null;</span>
        case 5:
<span class="nc" id="L967">          n = n.getElementAtLevelIndex( (key &gt;&gt;&gt; 25) &amp; 0x1f); </span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">          if (n == null) return null;</span>
        case 4:
<span class="fc" id="L970">          n = n.getElementAtLevelIndex( (key &gt;&gt;&gt; 20) &amp; 0x1f); </span>
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">          if (n == null) return null;</span>
        case 3:
<span class="nc" id="L973">          n = n.getElementAtLevelIndex( (key &gt;&gt;&gt; 15) &amp; 0x1f);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">          if (n == null) return null;</span>
        case 2:
<span class="fc" id="L976">          n = n.getElementAtLevelIndex( (key &gt;&gt;&gt; 10) &amp; 0x1f);</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">          if (n == null) return null;</span>
        case 1:
<span class="fc" id="L979">          n = n.getElementAtLevelIndex( (key &gt;&gt;&gt;  5) &amp; 0x1f);</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">          if (n == null) return null;</span>
        case 0: 
<span class="fc" id="L982">          return ((Node&lt;V&gt;)n).getElementAtLevelIndex(key &amp; 0x1f);</span>
      }
      
<span class="nc" id="L985">      return null; // can't get here</span>
    }
  }
  
  protected Node mergeStagingNode (){
<span class="fc" id="L990">    Node&lt;Node&gt; n2=null, n3=null, n4=null, n5=null, n6=null;</span>
<span class="fc" id="L991">    int i1, i2=0, i3=0, i4=0, i5=0, i6=0;</span>
    
<span class="fc" id="L993">    int k = stagingNodeMask;</span>
<span class="fc" id="L994">    Node&lt;Node&gt; n = rootNode;</span>
    
<span class="pc bpc" id="L996" title="5 of 8 branches missed.">    switch (rootLevel){</span>
      case 6: 
<span class="nc" id="L998">        i6 = (k &gt;&gt;&gt; 30);</span>
<span class="nc" id="L999">        n6 = n; </span>
<span class="nc" id="L1000">        n = n.getElementAtLevelIndex(i6);</span>
      case 5:
<span class="nc" id="L1002">        i5 = (k &gt;&gt;&gt; 25) &amp; 0x1f;</span>
<span class="nc" id="L1003">        n5 = n;</span>
<span class="nc" id="L1004">        n = n.getElementAtLevelIndex(i5);</span>
      case 4:
<span class="nc" id="L1006">        i4 = (k &gt;&gt;&gt; 20) &amp; 0x1f;</span>
<span class="nc" id="L1007">        n4 = n;</span>
<span class="nc" id="L1008">        n = n.getElementAtLevelIndex(i4);</span>
      case 3:
<span class="nc" id="L1010">        i3 = (k &gt;&gt;&gt; 15) &amp; 0x1f;</span>
<span class="nc" id="L1011">        n3 = n; </span>
<span class="nc" id="L1012">        n = n.getElementAtLevelIndex(i3);</span>
      case 2:
<span class="fc" id="L1014">        i2 = (k &gt;&gt;&gt; 10) &amp; 0x1f;</span>
<span class="fc" id="L1015">        n2 = n; </span>
<span class="fc" id="L1016">        n = n.getElementAtLevelIndex(i2);</span>
      case 1: 
<span class="fc" id="L1018">        i1 = (k &gt;&gt;&gt; 5) &amp; 0x1f;</span>
<span class="fc" id="L1019">        n = n.cloneWithReplaced(i1, stagingNode);</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        if (n2 != null){</span>
<span class="fc" id="L1021">          n = n2.cloneWithReplaced(i2, n);</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">          if (n3 != null){</span>
<span class="nc" id="L1023">            n = n3.cloneWithReplaced(i3, n);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">            if (n4 != null){</span>
<span class="nc" id="L1025">              n = n4.cloneWithReplaced(i4, n);</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">              if (n5 != null){</span>
<span class="nc" id="L1027">                n = n5.cloneWithReplaced(i5, n);</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                if (n6 != null){</span>
<span class="nc" id="L1029">                  n = n6.cloneWithReplaced(i6, n);</span>
                }
              }
            }
          }
        }
<span class="fc" id="L1035">        return n;</span>
        
      case 0:
        // special case - only node in the trie is the targetNode
<span class="fc" id="L1039">        return stagingNode;</span>
    }
    
<span class="nc" id="L1042">    return null; //  can't get here</span>
  }
  
  /**
   * this relies on that all nodes from the new staging node to the newRootNode have been copied
   * and can be modified without cloning.
   * The modification does not change the node type since the old staging/target node was in the trie
   * The first node where new and old staging indices differ is the mergeNode that needs to be
   * modified (old staging path node replaced). This has to be level 1..6
   * Everything above the mergeNode is not modified (the newRootNode does not have to be copied
   * as it is new)
   * All nodes between the old stagingNode and the mergeNode have to be copied
   * The old stagingNode itself does not need to be cloned.
   */
  protected void mergeStagingNode (int key, int newRootLevel, Node newRootNode){
<span class="fc" id="L1057">    int k = stagingNodeMask;</span>
<span class="fc" id="L1058">    int mergeLevel = getStartLevel( key ^ k); // block of first differing bit</span>
<span class="fc" id="L1059">    Node&lt;Node&gt; mergeNode = newRootNode;</span>
<span class="fc" id="L1060">    int shift = newRootLevel*5;</span>
    
    //--- get the mergeNode
<span class="fc bfc" id="L1063" title="All 2 branches covered.">    for (int l=newRootLevel; l&gt;mergeLevel; l--){</span>
<span class="fc" id="L1064">      int idx = (k &gt;&gt;&gt; shift) &amp; 0x1f;</span>
<span class="fc" id="L1065">      mergeNode = mergeNode.getElementAtLevelIndex(idx);</span>
<span class="fc" id="L1066">      shift -= 5;</span>
    }
<span class="fc" id="L1068">    int mergeIdx = (k &gt;&gt;&gt; shift) &amp; 0x1f;</span>
    
    //--- copy from old staging up to mergeNode
<span class="fc" id="L1071">    Node&lt;Node&gt; n5=null, n4=null, n3=null, n2=null, n1=null;</span>
<span class="fc" id="L1072">    int i5=0, i4=0, i3=0, i2=0, i1=0;</span>
<span class="fc" id="L1073">    Node&lt;Node&gt; n = mergeNode.getElementAtLevelIndex(mergeIdx);</span>
    
<span class="pc bpc" id="L1075" title="5 of 7 branches missed.">    switch (mergeLevel-1){ </span>
      case 5:        
<span class="nc" id="L1077">        i5 = (k &gt;&gt;&gt; 25) &amp; 0x1f;</span>
<span class="nc" id="L1078">        n5 = n;</span>
<span class="nc" id="L1079">        n = n.getElementAtLevelIndex(i5);</span>
      case 4:
<span class="nc" id="L1081">        i4 = (k &gt;&gt;&gt; 20) &amp; 0x1f;</span>
<span class="nc" id="L1082">        n4 = n;</span>
<span class="nc" id="L1083">        n = n.getElementAtLevelIndex(i4);</span>
      case 3:
<span class="nc" id="L1085">        i3 = (k &gt;&gt;&gt; 15) &amp; 0x1f;</span>
<span class="nc" id="L1086">        n3 = n;</span>
<span class="nc" id="L1087">        n = n.getElementAtLevelIndex(i3);</span>
      case 2:
<span class="nc" id="L1089">        i2 = (k &gt;&gt;&gt; 10) &amp; 0x1f;</span>
<span class="nc" id="L1090">        n2 = n;</span>
<span class="nc" id="L1091">        n = n.getElementAtLevelIndex(i2);</span>
      case 1:
<span class="fc" id="L1093">        i1 = (k &gt;&gt;&gt; 5) &amp; 0x1f;</span>
<span class="fc" id="L1094">        n1 = n;</span>
      case 0:
<span class="fc" id="L1096">        n = (Node)stagingNode;</span>
      
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        if (n1 != null){</span>
<span class="fc" id="L1099">          n = n1.cloneWithReplaced(i1, n);</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">          if (n2 != null) {</span>
<span class="nc" id="L1101">            n = n2.cloneWithReplaced(i2, n);</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">            if (n3 != null) {</span>
<span class="nc" id="L1103">              n = n3.cloneWithReplaced(i3, n);</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">              if (n4 != null) {</span>
<span class="nc" id="L1105">                n = n4.cloneWithReplaced(i4, n);</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                if (n5 != null) {</span>
<span class="nc" id="L1107">                  n = n5.cloneWithReplaced(i5, n);</span>
                }
              }
            }
          }          
        }
    }
    
    //--- modify mergeNode
<span class="fc" id="L1116">    mergeNode.set(mergeIdx, n);</span>
<span class="fc" id="L1117">  }</span>

  PSIntMap&lt;V&gt; remove (int key, boolean isTargetNode){
<span class="fc" id="L1120">    Node&lt;Node&gt; n6=null, n5=null, n4=null, n3=null, n2=null, n1=null;</span>
    Node&lt;V&gt; n0;
<span class="fc" id="L1122">    int i6=0, i5=0, i4=0, i3=0, i2=0, i1=0, i0;</span>
    
<span class="fc" id="L1124">    Node&lt;Node&gt; n = rootNode;</span>
<span class="pc bpc" id="L1125" title="5 of 8 branches missed.">    switch (rootLevel){</span>
      case 6:
<span class="nc" id="L1127">        i6 = (key &gt;&gt;&gt; 30);</span>
<span class="nc" id="L1128">        n5 = n.getElementAtLevelIndex(i6);</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        if (n5 == null){</span>
<span class="nc" id="L1130">          return this; // key not in map</span>
        } else {
<span class="nc" id="L1132">          n6 = n;</span>
<span class="nc" id="L1133">          n = n5;</span>
        }
      case 5:
<span class="nc" id="L1136">        i5 = (key &gt;&gt;&gt; 25) &amp; 0x1f;</span>
<span class="nc" id="L1137">        n4 = n.getElementAtLevelIndex(i5);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (n4 == null){</span>
<span class="nc" id="L1139">          return this; // key not in map</span>
        } else {
<span class="nc" id="L1141">          n5 = n;</span>
<span class="nc" id="L1142">          n = n4;</span>
        }
      case 4:
<span class="nc" id="L1145">        i4 = (key &gt;&gt;&gt; 20) &amp; 0x1f;</span>
<span class="nc" id="L1146">        n3 = n.getElementAtLevelIndex(i4);</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (n3 == null){</span>
<span class="nc" id="L1148">          return this; // key not in map</span>
        } else {
<span class="nc" id="L1150">          n4 = n;</span>
<span class="nc" id="L1151">          n = n3;</span>
        }
      case 3:
<span class="nc" id="L1154">        i3 = (key &gt;&gt;&gt; 15) &amp; 0x1f;</span>
<span class="nc" id="L1155">        n2 = n.getElementAtLevelIndex(i3);</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        if (n2 == null){</span>
<span class="nc" id="L1157">          return this; // key not in map</span>
        } else {
<span class="nc" id="L1159">          n3 = n;</span>
<span class="nc" id="L1160">          n = n2;</span>
        }
      case 2:
<span class="fc" id="L1163">        i2 = (key &gt;&gt;&gt; 10) &amp; 0x1f;</span>
<span class="fc" id="L1164">        n1 = n.getElementAtLevelIndex(i2);</span>
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">        if (n1 == null){</span>
<span class="nc" id="L1166">          return this; // key not in map</span>
        } else {
<span class="fc" id="L1168">          n2 = n;</span>
<span class="fc" id="L1169">          n = n1;</span>
        }
      case 1:
<span class="fc" id="L1172">        i1 = (key &gt;&gt;&gt; 5) &amp; 0x1f;</span>
<span class="fc" id="L1173">        n0 = n.getElementAtLevelIndex(i1);</span>
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">        if (n0 == null){</span>
<span class="nc" id="L1175">          return null;</span>
        } else {
<span class="fc" id="L1177">          n1 = n;</span>
<span class="fc" id="L1178">          n = (Node)n0;</span>
        }
        
      case 0:
<span class="fc" id="L1182">        n0 = (Node&lt;V&gt;)n;</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        if (isTargetNode){</span>
<span class="fc" id="L1184">          n0 = null;</span>
        } else {
<span class="fc" id="L1186">          i0 = key &amp; 0x1f;</span>
<span class="pc bpc" id="L1187" title="2 of 4 branches missed.">          if (n0 == null || n0.getElementAtLevelIndex(i0) == null){</span>
<span class="nc" id="L1188">            return this; // key not in map</span>
          } else {
<span class="fc" id="L1190">            n0 = n0.cloneWithRemoved(i0);</span>
          }
        }
<span class="fc" id="L1193">        n = (Node)n0;</span>
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        if (n1 != null){</span>
<span class="fc bfc" id="L1195" title="All 2 branches covered.">          n = (n == null) ? n1.cloneWithRemoved(i1) : n1.cloneWithReplaced(i1, n);</span>
<span class="fc bfc" id="L1196" title="All 2 branches covered.">          if (n2 != null){</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">            n = (n == null) ? n2.cloneWithRemoved(i2) : n2.cloneWithReplaced(i2, n);</span>
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">            if (n3 != null){</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">              n = (n == null) ? n3.cloneWithRemoved(i3) : n3.cloneWithReplaced(i3, n);</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">              if (n4 != null){</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">                n = (n == null) ? n4.cloneWithRemoved(i4) : n4.cloneWithReplaced(i4, n);</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                if (n5 != null){</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                  n = (n == null) ? n5.cloneWithRemoved(i5) : n5.cloneWithReplaced(i5, n);</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                  if (n6 != null){</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                    n = (n == null) ? n6.cloneWithRemoved(i6) : n6.cloneWithReplaced(i6, n);</span>
                  }
                }
              }
            }
          }
        }
        
<span class="fc bfc" id="L1213" title="All 2 branches covered.">        if (n == null){</span>
<span class="fc" id="L1214">          return new PSIntMap&lt;V&gt;();</span>
          
        } else {
<span class="fc" id="L1217">          int newRootLevel = rootLevel;</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">          int newSb = (n0 == null) ? 0 : (key | 0x1f);</span>
          
<span class="fc bfc" id="L1220" title="All 4 branches covered.">          while ((newRootLevel &gt; 0) &amp;&amp; n.isEmptyNode()){</span>
<span class="fc" id="L1221">            newRootLevel--;</span>
<span class="fc" id="L1222">            n = n.getElementAtLevelIndex(0);</span>
          }
          
<span class="pc bpc" id="L1225" title="1 of 4 branches missed.">          if (!isTargetNode &amp;&amp; (stagingNode != targetNode)){</span>
<span class="nc" id="L1226">            mergeStagingNode(key, newRootLevel, n);</span>
          }
          
<span class="fc" id="L1229">          return new PSIntMap&lt;V&gt;( size-1, newRootLevel, n, n0, n0, newSb);</span>
        }
    }
    
<span class="nc" id="L1233">    return null; // can't get here</span>
  }
  
  public PSIntMap&lt;V&gt; remove (int key){
<span class="fc" id="L1237">    int newSm = key | 0x1f;</span>

<span class="fc bfc" id="L1239" title="All 2 branches covered.">    if (newSm == stagingNodeMask){ // staging node hit - this should be the dominant case</span>
<span class="fc" id="L1240">      int i = key &amp; 0x1f;</span>
<span class="fc" id="L1241">      Node&lt;V&gt; n = stagingNode;</span>
<span class="pc bpc" id="L1242" title="1 of 2 branches missed.">      if ((n.getElementAtLevelIndex(i)) != null) { // key is in the stagingNode</span>
<span class="fc" id="L1243">        n = n.cloneWithRemoved(i);</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        if (n == null){ // staging node is empty, remove target node</span>
<span class="fc" id="L1245">          return remove(newSm, true);</span>
        } else { // non-empty staging node, just replace it
<span class="fc" id="L1247">          return new PSIntMap&lt;V&gt;( size-1, rootLevel, rootNode, n, targetNode, newSm);</span>
        }
        
      } else { // key wasn't in the stagingNode
<span class="nc" id="L1251">        return this;</span>
      }
      
    } else { // staging node miss
<span class="fc" id="L1255">      return remove( key, false);</span>
    }
  }
  
  /**
   * this either replaces or adds newElements new value 
   */
  public PSIntMap&lt;V&gt; set (int key, V value){
  
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">    if (value == null){</span>
      // we don't store null values, this is a remove in disguise
<span class="nc" id="L1266">      return remove(key);</span>
    }
    
<span class="fc" id="L1269">    int newSm = key | 0x1f;</span>
    
<span class="fc bfc" id="L1271" title="All 2 branches covered.">    if (newSm == stagingNodeMask){ // staging node hit - this should be the dominant case</span>
<span class="fc" id="L1272">      int i = key &amp; 0x1f;</span>
<span class="fc" id="L1273">      Node&lt;V&gt; n = stagingNode;</span>
<span class="fc" id="L1274">      int newSize = size;</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">      if ((n.getElementAtLevelIndex(i)) == null) {</span>
<span class="fc" id="L1276">        n = n.cloneWithAdded(i, value);</span>
<span class="fc" id="L1277">        newSize = size+1;</span>
      } else {
<span class="nc" id="L1279">        n = n.cloneWithReplaced(i, value);</span>
      }
<span class="fc" id="L1281">      return new PSIntMap&lt;V&gt;( newSize, rootLevel, rootNode, n, targetNode, newSm);</span>
      
    } else { // staging node miss
<span class="fc" id="L1284">      int newRootLevel = getStartLevel(key);</span>
      
<span class="fc bfc" id="L1286" title="All 2 branches covered.">      if (newRootLevel &gt; rootLevel){ // old trie has to be merged in</span>
<span class="fc" id="L1287">        return setInNewRootLevel( newRootLevel, key, value);</span>
        
      } else {     // new value can be added to old trie (stagingNode change)
<span class="fc" id="L1290">        return setInCurrentRootLevel( key, value);</span>
      }
    }
  }
  
  protected PSIntMap&lt;V&gt; setInNewRootLevel (int newRootLevel, int key, V value){
<span class="fc" id="L1296">    int newSm = key | 0x1f;</span>

    Node&lt;Node&gt; nOld;
<span class="fc bfc" id="L1299" title="All 2 branches covered.">    if (stagingNode != targetNode){</span>
<span class="fc" id="L1300">      nOld = mergeStagingNode();</span>
    } else {
<span class="fc" id="L1302">      nOld = rootNode;</span>
    }
    
    //--- expand old root upwards
<span class="fc bfc" id="L1306" title="All 2 branches covered.">    if (nOld != null){</span>
<span class="pc bpc" id="L1307" title="1 of 2 branches missed.">      for (int l = rootLevel + 1; l &lt; newRootLevel; l++) {</span>
<span class="nc" id="L1308">        nOld = new OneNode(0, nOld);</span>
      }
    }

    //--- create chain of new value nodes
<span class="fc" id="L1313">    int i = key &amp; 0x1f;</span>
<span class="fc" id="L1314">    Node nNew = new OneNode(i, value);</span>
<span class="fc" id="L1315">    int shift = 5;</span>
<span class="fc" id="L1316">    Node newStagingNode = nNew;</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">    for (int l = 1; l &lt; newRootLevel; l++) {</span>
<span class="fc" id="L1318">      i = (key &gt;&gt;&gt; shift) &amp; 0x1f;</span>
<span class="fc" id="L1319">      nNew = new OneNode(i, nNew);</span>
<span class="fc" id="L1320">      shift += 5;</span>
    }

    //--- create new root
<span class="fc" id="L1324">    i = (key &gt;&gt;&gt; shift); // no remainBmp needed, top level</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">    Node&lt;Node&gt; newRootNode = (nOld == null) ? new OneNode( i, nNew) : new BitmapNode&lt;Node&gt;(i, nNew, nOld);</span>

<span class="fc" id="L1327">    return new PSIntMap&lt;V&gt;(size + 1, newRootLevel, newRootNode, newStagingNode, newStagingNode, newSm);</span>
  }  
  
  /**
   * that's ugly, but if we use recursion we need newElements result object to obtain the new stagingNode and
   * the size change, which means there would be an additional allocation per set() or newElements non-persistent,
   * transient object that would need synchronization
   */
  protected PSIntMap&lt;V&gt; setInCurrentRootLevel (int key, V value){
<span class="fc" id="L1336">    Node&lt;Node&gt; n6=null, n5=null, n4=null, n3=null, n2=null, n1=null;</span>
    Node&lt;V&gt; n0;
<span class="fc" id="L1338">    int i6=0, i5=0, i4=0, i3=0, i2=0, i1=0, i0;</span>
<span class="fc" id="L1339">    int newSb = key | 0x1f;</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">    boolean needsMerge = (targetNode != stagingNode);</span>
<span class="fc" id="L1341">    int newSize = size+1;</span>
    
    //--- new stagingNode
<span class="fc" id="L1344">    Node&lt;Node&gt; n = rootNode;</span>

<span class="pc bpc" id="L1346" title="5 of 8 branches missed.">    switch(rootLevel){</span>
      case 6:
<span class="nc" id="L1348">        i6 = key &gt;&gt;&gt; 30;</span>
<span class="nc" id="L1349">        n5 = n.getElementAtLevelIndex(i6);</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (n5 == null) {</span>
<span class="nc" id="L1351">          n0 = new OneNode( (key &amp; 0x1f), value);</span>
<span class="nc" id="L1352">          n1 = new OneNode( (key &gt;&gt;&gt; 5) &amp; 0x1f, n0);</span>
<span class="nc" id="L1353">          n2 = new OneNode( (key &gt;&gt;&gt; 10) &amp; 0x1f, n1);</span>
<span class="nc" id="L1354">          n3 = new OneNode( (key &gt;&gt;&gt; 15) &amp; 0x1f, n2);</span>
<span class="nc" id="L1355">          n4 = new OneNode( (key &gt;&gt;&gt; 20) &amp; 0x1f, n3);</span>
<span class="nc" id="L1356">          n5 = new OneNode( (key &gt;&gt;&gt; 25) &amp; 0x1f, n4);</span>
<span class="nc" id="L1357">          n = n.cloneWithAdded( i6, n5);</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">          if (needsMerge) mergeStagingNode(key, rootLevel, n);</span>
<span class="nc" id="L1359">          return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>
          
        } else {
<span class="nc" id="L1362">          n6 = n;</span>
<span class="nc" id="L1363">          n = n5;</span>
        }

      case 5:
<span class="nc" id="L1367">        i5 = (key &gt;&gt;&gt; 25) &amp; 0x1f;</span>
<span class="nc" id="L1368">        n4 = n.getElementAtLevelIndex(i5);</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        if (n4 == null) {</span>
<span class="nc" id="L1370">          n0 = new OneNode( (key &amp; 0x1f), value);</span>
<span class="nc" id="L1371">          n1 = new OneNode( (key &gt;&gt;&gt; 5) &amp; 0x1f, n0);</span>
<span class="nc" id="L1372">          n2 = new OneNode( (key &gt;&gt;&gt; 10) &amp; 0x1f, n1);</span>
<span class="nc" id="L1373">          n3 = new OneNode( (key &gt;&gt;&gt; 15) &amp; 0x1f, n2);</span>
<span class="nc" id="L1374">          n4 = new OneNode( (key &gt;&gt;&gt; 20) &amp; 0x1f, n3);</span>
<span class="nc" id="L1375">          n = n.cloneWithAdded( i5, n4);</span>

<span class="nc bnc" id="L1377" title="All 2 branches missed.">          if (n6 != null){</span>
<span class="nc" id="L1378">            n = n6.cloneWithReplaced( i6, n);</span>
          }
<span class="nc bnc" id="L1380" title="All 2 branches missed.">          if (needsMerge) mergeStagingNode(key, rootLevel, n);</span>
<span class="nc" id="L1381">          return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>

        } else {
<span class="nc" id="L1384">          n5 = n;</span>
<span class="nc" id="L1385">          n = n4;</span>
        }

      case 4:
<span class="nc" id="L1389">        i4 = (key &gt;&gt;&gt; 20) &amp; 0x1f;</span>
<span class="nc" id="L1390">        n3 = n.getElementAtLevelIndex(i4);</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">        if (n3 == null) {</span>
<span class="nc" id="L1392">          n0 = new OneNode( (key &amp; 0x1f), value);</span>
<span class="nc" id="L1393">          n1 = new OneNode( (key &gt;&gt;&gt; 5) &amp; 0x1f, n0);</span>
<span class="nc" id="L1394">          n2 = new OneNode( (key &gt;&gt;&gt; 10) &amp; 0x1f, n1);</span>
<span class="nc" id="L1395">          n3 = new OneNode( (key &gt;&gt;&gt; 15) &amp; 0x1f, n2);</span>
<span class="nc" id="L1396">          n = n.cloneWithAdded( i4, n3);</span>

<span class="nc bnc" id="L1398" title="All 2 branches missed.">          if (n5 != null){</span>
<span class="nc" id="L1399">            n = n5.cloneWithReplaced( i5, n);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">            if (n6 != null){ </span>
<span class="nc" id="L1401">              n = n6.cloneWithReplaced( i6, n);</span>
            }
          }
<span class="nc bnc" id="L1404" title="All 2 branches missed.">          if (needsMerge) mergeStagingNode(key, rootLevel, n);</span>
<span class="nc" id="L1405">          return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>

        } else {
<span class="nc" id="L1408">          n4 = n;</span>
<span class="nc" id="L1409">          n = n3;</span>
        }
        
      case 3:
<span class="nc" id="L1413">        i3 = (key &gt;&gt;&gt; 15) &amp; 0x1f;</span>
<span class="nc" id="L1414">        n2 = n.getElementAtLevelIndex(i3);</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">        if (n2 == null) {</span>
<span class="nc" id="L1416">          n0 = new OneNode( (key &amp; 0x1f), value);</span>
<span class="nc" id="L1417">          n1 = new OneNode( (key &gt;&gt;&gt; 5) &amp; 0x1f, n0);</span>
<span class="nc" id="L1418">          n2 = new OneNode( (key &gt;&gt;&gt; 10) &amp; 0x1f, n1);</span>
<span class="nc" id="L1419">          n = n.cloneWithAdded( i3, n2);</span>

<span class="nc bnc" id="L1421" title="All 2 branches missed.">          if (n4 != null){</span>
<span class="nc" id="L1422">            n = n4.cloneWithReplaced( i4, n);</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            if (n5 != null){</span>
<span class="nc" id="L1424">              n = n5.cloneWithReplaced( i5, n);</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">              if (n6 != null){ </span>
<span class="nc" id="L1426">                n = n6.cloneWithReplaced( i6, n);</span>
              }
            }
          }
<span class="nc bnc" id="L1430" title="All 2 branches missed.">          if (needsMerge) mergeStagingNode(key, rootLevel, n);</span>
<span class="nc" id="L1431">          return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>

        } else {
<span class="nc" id="L1434">          n3 = n;</span>
<span class="nc" id="L1435">          n = n2;</span>
        }
        
      case 2:
<span class="fc" id="L1439">        i2 = (key &gt;&gt;&gt; 10) &amp; 0x1f;</span>
<span class="fc" id="L1440">        n1 = n.getElementAtLevelIndex(i2);</span>
<span class="fc bfc" id="L1441" title="All 2 branches covered.">        if (n1 == null) {</span>
<span class="fc" id="L1442">          n0 = new OneNode( (key &amp; 0x1f), value);</span>
<span class="fc" id="L1443">          n1 = new OneNode( (key &gt;&gt;&gt; 5) &amp; 0x1f, n0);</span>
<span class="fc" id="L1444">          n = n.cloneWithAdded( i2, n1);</span>

<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">          if (n3 != null){</span>
<span class="nc" id="L1447">            n = n3.cloneWithReplaced( i3, n);</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            if (n4 != null){</span>
<span class="nc" id="L1449">              n = n4.cloneWithReplaced( i4, n);</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">              if (n5 != null){</span>
<span class="nc" id="L1451">                n = n5.cloneWithReplaced( i5, n);</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">                if (n6 != null){ </span>
<span class="nc" id="L1453">                  n = n6.cloneWithReplaced( i6, n);</span>
                }
              }
            }
          }
<span class="pc bpc" id="L1458" title="1 of 2 branches missed.">          if (needsMerge) mergeStagingNode(key, rootLevel, n);</span>
<span class="fc" id="L1459">          return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>

        } else {
<span class="fc" id="L1462">          n2 = n;</span>
<span class="fc" id="L1463">          n = n1;</span>
        }
 
      case 1:
<span class="fc" id="L1467">        i1 = (key &gt;&gt;&gt; 5) &amp; 0x1f;</span>
<span class="fc" id="L1468">        n0 = n.getElementAtLevelIndex(i1);</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">        if (n0 == null) {</span>
<span class="fc" id="L1470">          n0 = new OneNode( (key &amp; 0x1f), value);</span>
<span class="fc" id="L1471">          n = n.cloneWithAdded( i1, n0);</span>

<span class="fc bfc" id="L1473" title="All 2 branches covered.">          if (n2 != null){</span>
<span class="fc" id="L1474">            n = n2.cloneWithReplaced( i2, n);</span>
<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">            if (n3 != null){</span>
<span class="nc" id="L1476">              n = n3.cloneWithReplaced( i3, n);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">              if (n4 != null){</span>
<span class="nc" id="L1478">                n = n4.cloneWithReplaced( i4, n);</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                if (n5 != null){</span>
<span class="nc" id="L1480">                  n = n5.cloneWithReplaced( i5, n);</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                  if (n6 != null){ </span>
<span class="nc" id="L1482">                    n = n6.cloneWithReplaced( i6, n);</span>
                  }
                }
              }
            }
          }
<span class="fc bfc" id="L1488" title="All 2 branches covered.">          if (needsMerge) mergeStagingNode(key, rootLevel, n);</span>
<span class="fc" id="L1489">          return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>

        } else {
<span class="fc" id="L1492">          n1 = n;</span>
<span class="fc" id="L1493">          n = (Node)n0;</span>
        }
 
      case 0: // finally the value level
<span class="fc" id="L1497">        i0 = key &amp; 0x1f;</span>
<span class="fc" id="L1498">        n0 = (Node&lt;V&gt;)n;</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">        if (n0 != null){</span>
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">          if (n0.getElementAtLevelIndex(i0) == null) {</span>
<span class="fc" id="L1501">            n0 = n0.cloneWithAdded(i0, value);</span>
          } else {
<span class="nc" id="L1503">            n0 = n0.cloneWithReplaced(i0, value);</span>
<span class="nc" id="L1504">            newSize = size;</span>
          }
        } else { // first node
<span class="fc" id="L1507">          n0 = new OneNode( i0, value);</span>
<span class="fc" id="L1508">          newSize = 1;</span>
        }
        
<span class="fc" id="L1511">        n = (Node)n0;</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        if (n1 != null){</span>
<span class="fc" id="L1513">          n = n1.cloneWithReplaced( i1, n);</span>
<span class="fc bfc" id="L1514" title="All 2 branches covered.">          if (n2 != null){</span>
<span class="fc" id="L1515">            n = n2.cloneWithReplaced( i2, n);</span>
<span class="pc bpc" id="L1516" title="1 of 2 branches missed.">            if (n3 != null){</span>
<span class="nc" id="L1517">              n = n3.cloneWithReplaced( i3, n);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">              if (n4 != null){</span>
<span class="nc" id="L1519">                n = n4.cloneWithReplaced( i4, n);</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                if (n5 != null){</span>
<span class="nc" id="L1521">                  n = n5.cloneWithReplaced( i5, n);</span>
<span class="nc bnc" id="L1522" title="All 2 branches missed.">                  if (n6 != null){</span>
<span class="nc" id="L1523">                    n = n6.cloneWithReplaced( i6, n);</span>
                  }
                }
              }
            }
          } 
        }
<span class="fc bfc" id="L1530" title="All 2 branches covered.">        if (needsMerge) mergeStagingNode( key, rootLevel, n);</span>
<span class="fc" id="L1531">        return new PSIntMap&lt;V&gt;( newSize, rootLevel, n, n0, n0, newSb);</span>
    }
    
<span class="nc" id="L1534">    return null; // can't get here</span>
  }

  
  public void process (Processor&lt;V&gt; p){
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">    if (rootNode != null){</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">      if (targetNode == stagingNode){</span>
<span class="fc" id="L1541">        rootNode.process( rootLevel, null, null, p);</span>
      } else {
<span class="fc" id="L1543">        rootNode.process( rootLevel, targetNode, stagingNode, p);</span>
      }
    }
<span class="fc" id="L1546">  }</span>
    
  final protected Node removeAllSatisfying (int level, Node node, Predicate&lt;V&gt; pred){
<span class="fc bfc" id="L1549" title="All 2 branches covered.">    if (level == 0){ // value level</span>
<span class="fc" id="L1550">      return ((Node&lt;V&gt;)node).removeAllSatisfying(pred);</span>
      
    } else { // node level
      // it sucks not having stack arrays but we don't want to allocate for temporary results
<span class="fc" id="L1554">      Node n0=null,n1=null,n2=null,n3=null,n4=null,n5=null,n6=null,n7=null,n8=null,n9=null,n10=null,</span>
<span class="fc" id="L1555">           n11=null,n12=null,n13=null,n14=null,n15=null,n16=null,n17=null,n18=null,n19=null,n20=null,</span>
<span class="fc" id="L1556">           n21=null,n22=null,n23=null,n24=null,n25=null,n26=null,n27=null,n28=null,n29=null,n30=null,n31=null;</span>
<span class="fc" id="L1557">      int nRemaining = 0, nChanged = 0;</span>
<span class="fc" id="L1558">      int len = node.getNumberOfElements();</span>
      
      //--- collect the remaining nodes
<span class="fc bfc" id="L1561" title="All 2 branches covered.">      for (int i=0; i&lt;len; i++){</span>
<span class="fc" id="L1562">        Node e = (Node)node.getElementAtStorageIndex(i);</span>
<span class="fc" id="L1563">        Node n = removeAllSatisfying( level-1, e, pred);</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">        if (n != null){</span>
<span class="fc" id="L1565">          nRemaining++;</span>
<span class="fc bfc" id="L1566" title="All 2 branches covered.">          if (n != e){</span>
<span class="fc" id="L1567">            nChanged++;</span>
          }
<span class="pc bpc" id="L1569" title="1 of 33 branches missed.">          switch (i){</span>
<span class="fc" id="L1570">            case  0:  n0=n; break;</span>
<span class="fc" id="L1571">            case  1:  n1=n; break;</span>
<span class="fc" id="L1572">            case  2:  n2=n; break;</span>
<span class="fc" id="L1573">            case  3:  n3=n; break;</span>
<span class="fc" id="L1574">            case  4:  n4=n; break;</span>
<span class="fc" id="L1575">            case  5:  n5=n; break;</span>
<span class="fc" id="L1576">            case  6:  n6=n; break;</span>
<span class="fc" id="L1577">            case  7:  n7=n; break;</span>
<span class="fc" id="L1578">            case  8:  n8=n; break;</span>
<span class="fc" id="L1579">            case  9:  n9=n; break;</span>
<span class="fc" id="L1580">            case 10: n10=n; break;</span>
<span class="fc" id="L1581">            case 11: n11=n; break;</span>
<span class="fc" id="L1582">            case 12: n12=n; break;</span>
<span class="fc" id="L1583">            case 13: n13=n; break;</span>
<span class="fc" id="L1584">            case 14: n14=n; break;</span>
<span class="fc" id="L1585">            case 15: n15=n; break;</span>
<span class="fc" id="L1586">            case 16: n16=n; break;</span>
<span class="fc" id="L1587">            case 17: n17=n; break;</span>
<span class="fc" id="L1588">            case 18: n18=n; break;</span>
<span class="fc" id="L1589">            case 19: n19=n; break;</span>
<span class="fc" id="L1590">            case 20: n20=n; break;</span>
<span class="fc" id="L1591">            case 21: n21=n; break;</span>
<span class="fc" id="L1592">            case 22: n22=n; break;</span>
<span class="fc" id="L1593">            case 23: n23=n; break;</span>
<span class="fc" id="L1594">            case 24: n24=n; break;</span>
<span class="fc" id="L1595">            case 25: n25=n; break;</span>
<span class="fc" id="L1596">            case 26: n26=n; break;</span>
<span class="fc" id="L1597">            case 27: n27=n; break;</span>
<span class="fc" id="L1598">            case 28: n28=n; break;</span>
<span class="fc" id="L1599">            case 29: n29=n; break;</span>
<span class="fc" id="L1600">            case 30: n30=n; break;</span>
<span class="fc" id="L1601">            case 31: n31=n; break;</span>
          }
        }
      }
      
      //--- construct the returned node
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">      if (nRemaining == 0){</span>
<span class="nc" id="L1608">        return null;</span>
        
<span class="fc bfc" id="L1610" title="All 4 branches covered.">      } else if ((nRemaining == len) &amp;&amp; (nChanged == 0)){</span>
<span class="fc" id="L1611">        return node;</span>
        
      } else {
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">        if (nRemaining == 1){ // becomes a OneNode</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">          for (int i=0; i&lt;32; i++){</span>
<span class="nc bnc" id="L1616" title="All 33 branches missed.">            switch (i){</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">              case  0:  if  (n0!=null) return new OneNode( node.storageToLevelIndex(0), n0); break;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">              case  1:  if  (n1!=null) return new OneNode( node.storageToLevelIndex(1), n1); break;</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">              case  2:  if  (n2!=null) return new OneNode( node.storageToLevelIndex(2), n2); break;</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">              case  3:  if  (n3!=null) return new OneNode( node.storageToLevelIndex(3), n3); break;</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">              case  4:  if  (n4!=null) return new OneNode( node.storageToLevelIndex(4), n4); break;</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">              case  5:  if  (n5!=null) return new OneNode( node.storageToLevelIndex(5), n5); break;</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">              case  6:  if  (n6!=null) return new OneNode( node.storageToLevelIndex(6), n6); break;</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">              case  7:  if  (n7!=null) return new OneNode( node.storageToLevelIndex(7), n7); break;</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">              case  8:  if  (n8!=null) return new OneNode( node.storageToLevelIndex(8), n8); break;</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">              case  9:  if  (n9!=null) return new OneNode( node.storageToLevelIndex(9), n9); break;</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">              case 10:  if (n10!=null) return new OneNode( node.storageToLevelIndex(10),n10); break;</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">              case 11:  if (n11!=null) return new OneNode( node.storageToLevelIndex(11),n11); break;</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">              case 12:  if (n12!=null) return new OneNode( node.storageToLevelIndex(12),n12); break;</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">              case 13:  if (n13!=null) return new OneNode( node.storageToLevelIndex(13),n13); break;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">              case 14:  if (n14!=null) return new OneNode( node.storageToLevelIndex(14),n14); break;</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">              case 15:  if (n15!=null) return new OneNode( node.storageToLevelIndex(15),n15); break;</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">              case 16:  if (n16!=null) return new OneNode( node.storageToLevelIndex(16),n16); break;</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">              case 17:  if (n17!=null) return new OneNode( node.storageToLevelIndex(17),n17); break;</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">              case 18:  if (n18!=null) return new OneNode( node.storageToLevelIndex(18),n18); break;</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">              case 19:  if (n19!=null) return new OneNode( node.storageToLevelIndex(19),n19); break;</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">              case 20:  if (n20!=null) return new OneNode( node.storageToLevelIndex(20),n20); break;</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">              case 21:  if (n21!=null) return new OneNode( node.storageToLevelIndex(21),n21); break;</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">              case 22:  if (n22!=null) return new OneNode( node.storageToLevelIndex(22),n22); break;</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">              case 23:  if (n23!=null) return new OneNode( node.storageToLevelIndex(23),n23); break;</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">              case 24:  if (n24!=null) return new OneNode( node.storageToLevelIndex(24),n24); break;</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">              case 25:  if (n25!=null) return new OneNode( node.storageToLevelIndex(25),n25); break;</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">              case 26:  if (n26!=null) return new OneNode( node.storageToLevelIndex(26),n26); break;</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">              case 27:  if (n27!=null) return new OneNode( node.storageToLevelIndex(27),n27); break;</span>
<span class="nc bnc" id="L1645" title="All 2 branches missed.">              case 28:  if (n28!=null) return new OneNode( node.storageToLevelIndex(28),n28); break;</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">              case 29:  if (n29!=null) return new OneNode( node.storageToLevelIndex(29),n29); break;</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">              case 30:  if (n30!=null) return new OneNode( node.storageToLevelIndex(30),n30); break;</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">              case 31:  if (n31!=null) return new OneNode( node.storageToLevelIndex(31),n31); break;</span>
            }
          }
          
<span class="fc bfc" id="L1652" title="All 2 branches covered.">        } else if (nRemaining == 32) { // still a FullNode, but elements might have changed</span>
<span class="fc" id="L1653">          Node[] a = {n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,</span>
                      n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,
                      n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31};
          
<span class="fc" id="L1657">          return new FullNode(a);</span>
          
        } else {
<span class="fc" id="L1660">          int bitmap = 0;</span>
<span class="fc" id="L1661">          Node[] a = new Node[nRemaining];</span>
<span class="fc" id="L1662">          int j=0;</span>

          // &lt;2do&gt; this is bad - there has to be a more efficient way to generate the bitmap
<span class="fc bfc" id="L1665" title="All 2 branches covered.">          for (int i=0; j &lt; nRemaining; i++){</span>
<span class="pc bpc" id="L1666" title="1 of 33 branches missed.">            switch (i){</span>
<span class="fc bfc" id="L1667" title="All 2 branches covered.">              case  0:  if  (n0!=null) { a[j++] =  n0; bitmap |= (1&lt;&lt;node.storageToLevelIndex(0)); } break;</span>
<span class="pc bpc" id="L1668" title="1 of 2 branches missed.">              case  1:  if  (n1!=null) { a[j++] =  n1; bitmap |= (1&lt;&lt;node.storageToLevelIndex(1)); } break;</span>
<span class="fc bfc" id="L1669" title="All 2 branches covered.">              case  2:  if  (n2!=null) { a[j++] =  n2; bitmap |= (1&lt;&lt;node.storageToLevelIndex(2)); } break;</span>
<span class="fc bfc" id="L1670" title="All 2 branches covered.">              case  3:  if  (n3!=null) { a[j++] =  n3; bitmap |= (1&lt;&lt;node.storageToLevelIndex(3)); } break;</span>
<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">              case  4:  if  (n4!=null) { a[j++] =  n4; bitmap |= (1&lt;&lt;node.storageToLevelIndex(4)); } break;</span>
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">              case  5:  if  (n5!=null) { a[j++] =  n5; bitmap |= (1&lt;&lt;node.storageToLevelIndex(5)); } break;</span>
<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">              case  6:  if  (n6!=null) { a[j++] =  n6; bitmap |= (1&lt;&lt;node.storageToLevelIndex(6)); } break;</span>
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">              case  7:  if  (n7!=null) { a[j++] =  n7; bitmap |= (1&lt;&lt;node.storageToLevelIndex(7)); } break;</span>
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">              case  8:  if  (n8!=null) { a[j++] =  n8; bitmap |= (1&lt;&lt;node.storageToLevelIndex(8)); } break;</span>
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">              case  9:  if  (n9!=null) { a[j++] =  n9; bitmap |= (1&lt;&lt;node.storageToLevelIndex(9)); } break;</span>
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">              case 10:  if (n10!=null) { a[j++] = n10; bitmap |= (1&lt;&lt;node.storageToLevelIndex(10)); } break;</span>
<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">              case 11:  if (n11!=null) { a[j++] = n11; bitmap |= (1&lt;&lt;node.storageToLevelIndex(11)); } break;</span>
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">              case 12:  if (n12!=null) { a[j++] = n12; bitmap |= (1&lt;&lt;node.storageToLevelIndex(12)); } break;</span>
<span class="pc bpc" id="L1680" title="1 of 2 branches missed.">              case 13:  if (n13!=null) { a[j++] = n13; bitmap |= (1&lt;&lt;node.storageToLevelIndex(13)); } break;</span>
<span class="pc bpc" id="L1681" title="1 of 2 branches missed.">              case 14:  if (n14!=null) { a[j++] = n14; bitmap |= (1&lt;&lt;node.storageToLevelIndex(14)); } break;</span>
<span class="pc bpc" id="L1682" title="1 of 2 branches missed.">              case 15:  if (n15!=null) { a[j++] = n15; bitmap |= (1&lt;&lt;node.storageToLevelIndex(15)); } break;</span>
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">              case 16:  if (n16!=null) { a[j++] = n16; bitmap |= (1&lt;&lt;node.storageToLevelIndex(16)); } break;</span>
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">              case 17:  if (n17!=null) { a[j++] = n17; bitmap |= (1&lt;&lt;node.storageToLevelIndex(17)); } break;</span>
<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">              case 18:  if (n18!=null) { a[j++] = n18; bitmap |= (1&lt;&lt;node.storageToLevelIndex(18)); } break;</span>
<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">              case 19:  if (n19!=null) { a[j++] = n19; bitmap |= (1&lt;&lt;node.storageToLevelIndex(19)); } break;</span>
<span class="pc bpc" id="L1687" title="1 of 2 branches missed.">              case 20:  if (n20!=null) { a[j++] = n20; bitmap |= (1&lt;&lt;node.storageToLevelIndex(20)); } break;</span>
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">              case 21:  if (n21!=null) { a[j++] = n21; bitmap |= (1&lt;&lt;node.storageToLevelIndex(21)); } break;</span>
<span class="pc bpc" id="L1689" title="1 of 2 branches missed.">              case 22:  if (n22!=null) { a[j++] = n22; bitmap |= (1&lt;&lt;node.storageToLevelIndex(22)); } break;</span>
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">              case 23:  if (n23!=null) { a[j++] = n23; bitmap |= (1&lt;&lt;node.storageToLevelIndex(23)); } break;</span>
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">              case 24:  if (n24!=null) { a[j++] = n24; bitmap |= (1&lt;&lt;node.storageToLevelIndex(24)); } break;</span>
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">              case 25:  if (n25!=null) { a[j++] = n25; bitmap |= (1&lt;&lt;node.storageToLevelIndex(25)); } break;</span>
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">              case 26:  if (n26!=null) { a[j++] = n26; bitmap |= (1&lt;&lt;node.storageToLevelIndex(26)); } break;</span>
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">              case 27:  if (n27!=null) { a[j++] = n27; bitmap |= (1&lt;&lt;node.storageToLevelIndex(27)); } break;</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">              case 28:  if (n28!=null) { a[j++] = n28; bitmap |= (1&lt;&lt;node.storageToLevelIndex(28)); } break;</span>
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">              case 29:  if (n29!=null) { a[j++] = n29; bitmap |= (1&lt;&lt;node.storageToLevelIndex(29)); } break;</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">              case 30:  if (n30!=null) { a[j++] = n30; bitmap |= (1&lt;&lt;node.storageToLevelIndex(30)); } break;</span>
<span class="pc bpc" id="L1698" title="1 of 2 branches missed.">              case 31:  if (n31!=null) { a[j++] = n31; bitmap |= (1&lt;&lt;node.storageToLevelIndex(31)); } break;</span>
            }
          }
          
<span class="fc" id="L1702">          return new BitmapNode( bitmap, a);</span>
        }
      }
    }
    
<span class="nc" id="L1707">    throw new RuntimeException(&quot;can't get here&quot;);</span>
  }
  
  public PSIntMap&lt;V&gt; removeAllSatisfying( Predicate&lt;V&gt; pred){
<span class="fc" id="L1711">    Node&lt;Node&gt; node = rootNode;</span>
    
<span class="fc bfc" id="L1713" title="All 2 branches covered.">    if (stagingNode != targetNode){</span>
      // we need to merge first since the target node might be gone after bulk removal
<span class="fc" id="L1715">      node = mergeStagingNode();</span>
    }
<span class="fc" id="L1717">    node = removeAllSatisfying( rootLevel, node, pred);</span>
    
    // reduce depth
    
<span class="fc" id="L1721">    int newRootLevel = rootLevel;</span>
<span class="fc" id="L1722">    int newSize = countSize( newRootLevel, node);</span>
    
<span class="fc" id="L1724">    return new PSIntMap&lt;V&gt;( newSize, newRootLevel, node, null, null, 0);    </span>
  }
  
  protected final int countSize (int level, Node node){
<span class="pc bpc" id="L1728" title="1 of 2 branches missed.">    if (node == null){</span>
<span class="nc" id="L1729">      return 0;</span>
      
    } else {
<span class="fc bfc" id="L1732" title="All 2 branches covered.">      if (level == 0) {</span>
<span class="fc" id="L1733">        return node.getNumberOfElements();</span>

      } else {
<span class="fc" id="L1736">        int nValues = 0;</span>
<span class="fc" id="L1737">        int len = node.getNumberOfElements();</span>
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1739">          nValues += countSize(level - 1, (Node) node.getElementAtStorageIndex(i));</span>
        }
<span class="fc" id="L1741">        return nValues;</span>
      }
    }
  }
  
  public V[] values (){
<span class="nc" id="L1747">    final Object[] values = new Object[size];</span>
<span class="nc" id="L1748">    Processor&lt;V&gt; flattener = new Processor&lt;V&gt;(){</span>
<span class="nc" id="L1749">      int i=0;</span>
      @Override
	public void process (V v){
<span class="nc" id="L1752">        values[i] = v;</span>
<span class="nc" id="L1753">      }</span>
    };
    
<span class="nc" id="L1756">    process(flattener);</span>
    
<span class="nc" id="L1758">    return (V[])values;</span>
  }
  
  //--- debugging
  
  public void printOn(PrintStream ps) {
<span class="pc bpc" id="L1764" title="1 of 2 branches missed.">    if (rootNode != null) {</span>
<span class="fc" id="L1765">      rootNode.printNodeInfoOn(ps, targetNode, stagingNode);</span>
<span class="fc" id="L1766">      ps.println();</span>
<span class="fc" id="L1767">      rootNode.printOn(ps, rootLevel, targetNode, stagingNode);</span>
    } else {
<span class="nc" id="L1769">      ps.println( &quot;empty&quot;);</span>
    }

<span class="fc bfc" id="L1772" title="All 2 branches covered.">    if (stagingNode != null) {</span>
<span class="fc" id="L1773">      ps.println(&quot;--------------- staging&quot;);</span>
<span class="fc" id="L1774">      stagingNode.printNodeInfoOn(ps, targetNode, stagingNode);</span>
<span class="fc" id="L1775">      ps.println();</span>
<span class="fc" id="L1776">      stagingNode.printOn(ps, 0, targetNode, stagingNode);</span>
    }
<span class="fc" id="L1778">  }</span>
  
  public String keyDescription (int key) {
<span class="nc" id="L1781">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1782">    int ish = getStartLevel(key);</span>
    
<span class="nc" id="L1784">    sb.append(key);</span>
<span class="nc" id="L1785">    sb.append(&quot; (0x&quot;);</span>
<span class="nc" id="L1786">    sb.append(Integer.toHexString(key));</span>
<span class="nc" id="L1787">    sb.append(&quot;) =&gt; &quot;);</span>
    
<span class="nc bnc" id="L1789" title="All 2 branches missed.">    for (int shift=ish*5; shift&gt;=0; shift-=5) {</span>
<span class="nc" id="L1790">      sb.append((key&gt;&gt;shift) &amp; 0x1f);</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">      if (shift &gt; 0) {</span>
<span class="nc" id="L1792">        sb.append('.');</span>
      }
    }
    
<span class="nc" id="L1796">    return sb.toString();</span>
  }
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>