<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Config.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jpf-core</a> &gt; <a href="index.source.html" class="el_package">gov.nasa.jpf</a> &gt; <span class="el_source">Config.java</span></div><h1>Config.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014, United States Government, as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All rights reserved.
 *
 * The Java Pathfinder core (jpf-core) platform is licensed under the
 * Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0. 
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */
package gov.nasa.jpf;


import gov.nasa.jpf.util.FileUtils;
import gov.nasa.jpf.util.JPFSiteUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Logger;
import java.util.regex.Pattern;


/**
 * class that encapsulates property-based JPF configuration. This is mainly an
 * associative array with various typed accessors, and a structured
 * initialization process. This implementation has the design constraint that it
 * does not promote symbolic information to concrete types, which means that
 * frequently accessed data should be promoted and cached in client classes.
 * This in turn means we assume the data is not going to change at runtime.
 * Major motivation for this mechanism is to avoid 'Option' classes that have
 * concrete type fields, and hence are structural bottlenecks, i.e. every
 * parameterized user extension (Heuristics, Scheduler etc.) require to update
 * this single class. Note that Config is also not thread safe with respect to
 * retrieving exceptions that occurred during instantiation
 *
 * Another important caveat for both implementation and usage of Config is that
 * it is supposed to be our master configuration mechanism, i.e. it is also used
 * to configure other core services like logging. This means that Config
 * initialization should not depend on these services. Initialization has to
 * return at all times, recording potential problems for later handling. This is
 * why we have to keep the Config data model and initialization fairly simple
 * and robust.
 *
 * Except of JPF and Config itself, all JPF classes are loaded by a
 * Classloader that is constucted by Config (e.g. by collecting jars from
 * known/configured locations), i.e. we SHOULD NOT rely on any 3rd party
 * libraries within Config. The class should be as autarkical as possible.
 *
 *
 * PROPERTY SOURCES
 * ----------------
 *
 * (1) one site.properties - this file specifies the location of the jpf-core and
 * installed extensions, like:
 *
 *     jpf-core = /Users/pcmehlitz/projects/jpf/jpf-core
 *     ...
 *     jpf-numeric = /Users/pcmehlitz/projects/jpf/jpf-numeric
 *     ...
 *     extensions = ${jpf-core}
 *
 * Each key/directory that is in site.properties is used to locate a corresponding
 * project property (jpf.properties) file
 *
 * (2) any number of jpf.properties project properties files - each directory
 * entry in the 'extensions' list is checked for a jpf.properties file, which 
 * is automatically loaded if found. Project properties mostly contain path 
 * settings that are used to initialize class loading by the host VM and JPF
 *
 * (3) one *.jpf application properties - this specifies all the settings for a
 * specific JPF run, esp. listener and target/target.args.
 * app properties can be specified as the sole JPF argument, i.e. instead of
 * a SUT classname
 *     ..
 *     target = x.Y.MySystemUnderTest
 *     target.args = one,two
 *     ..
 *     listener = z.MyListener
 *
 * (4) commandline properties - all start with '+', they can override all other props
 *
 *
 * LOOKUP ORDER
 * ------------
 *                       property lookup
 *   property type   :      spec             :  default
 *   ----------------:-----------------------:----------
 * |  site           :   +site               : &quot;${user.home}/[.]jpf/site.properties&quot;
 * |                 :                       :
 * |  project        :  'extensions' value   : set in site.properties
 * |                 :                       :
 * |  app            :   +app                : -
 * |                 :                       :
 * v  cmdline        :   +&lt;key&gt;=&lt;val&gt;        : -
 *
 * * if there is an explicit spec and the pathname does not exist, throw a
 * JPFConfigException
 *
 * * if the system properties cannot be found, throw a JPFConfigException
 *
 *
 * &lt;2do&gt; need to make NumberFormatException handling consistent - should always
 * throw an JPFConfigException, not silently returning the default value
 *
 */


@SuppressWarnings(&quot;serial&quot;)
public class Config extends Properties {

  static final char   KEY_PREFIX = '@';
  public static final String REQUIRES_KEY = &quot;@requires&quot;;
  public static final String INCLUDE_KEY = &quot;@include&quot;;
  public static final String INCLUDE_UNLESS_KEY = &quot;@include_unless&quot;;
  public static final String INCLUDE_IF_KEY = &quot;@include_if&quot;;
  public static final String USING_KEY = &quot;@using&quot;;

<span class="fc" id="L143">  static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

  public static final String LIST_SEPARATOR = &quot;,&quot;;
  public static final String PATH_SEPARATOR = &quot;,&quot;; // the default for automatic appends

<span class="fc" id="L148">  public static final Class&lt;?&gt;[] CONFIG_ARGTYPES = { Config.class };  </span>
<span class="fc" id="L149">  public static final Class&lt;?&gt;[] NO_ARGTYPES = new Class&lt;?&gt;[0];</span>
<span class="fc" id="L150">  public static final Object[] NO_ARGS = new Object[0];</span>

  public static final String TRUE = &quot;true&quot;;
  public static final String FALSE = &quot;false&quot;;
  
  static final String MAX = &quot;MAX&quot;;

  static final String IGNORE_VALUE = &quot;-&quot;;

  // maximum number of processes for distributed applications
<span class="fc" id="L160">  public static int MAX_NUM_PRC = 16;</span>

  // do we want to log the config init
<span class="fc" id="L163">  public static boolean log = false;</span>

  // bad - a control exception
  static class MissingRequiredKeyException extends RuntimeException {
    MissingRequiredKeyException(String details){
<span class="fc" id="L168">      super(details);</span>
<span class="fc" id="L169">    }</span>
  }

  // it seems bad design to keep ClassLoader management in a glorified Properties object,
  // but a lot of what Config does is to resolve configured types, for which we need
  // control over the loader that is used for resolution
<span class="pc" id="L175">  ClassLoader loader = Config.class.getClassLoader();</span>
    
  // where did we initialize from
<span class="pc" id="L178">  ArrayList&lt;Object&gt; sources = new ArrayList&lt;Object&gt;();</span>
  
  ArrayList&lt;ConfigChangeListener&gt; changeListeners;
  
  // Properties are simple Hashmaps, but we want to maintain the order of entries
<span class="pc" id="L183">  LinkedList&lt;String&gt; entrySequence = new LinkedList&lt;String&gt;();</span>

  // an [optional] hashmap to keep objects we want to be singletons
  HashMap&lt;String,Object&gt; singletons;
  
<span class="pc" id="L188">  public final Object[] CONFIG_ARGS = { this };</span>

  // the original command line args that were passed into the constructor
  String[] args;
  
  // non-property/option command line args (starting from the first arg that is not prepened by '-','+')
  String[] freeArgs;

  /**
   * the standard Config constructor that processes the whole properties stack
   */
<span class="fc" id="L199">  public Config (String[] cmdLineArgs)  {</span>
<span class="fc" id="L200">    args = cmdLineArgs;</span>
<span class="fc" id="L201">    String[] a = cmdLineArgs.clone(); // we might nullify some of them</span>

    // we need the app properties (*.jpf) pathname upfront because it might define 'site'
<span class="fc" id="L204">    String appProperties = getAppPropertiesLocation(a);</span>

    //--- the site properties
<span class="fc" id="L207">    String siteProperties = getSitePropertiesLocation( a, appProperties);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (siteProperties != null){</span>
<span class="fc" id="L209">      loadProperties( siteProperties);</span>
    }

    //--- get the project properties from current dir + site configured extensions
<span class="fc" id="L213">    loadProjectProperties();</span>

    //--- the application properties
<span class="fc bfc" id="L216" title="All 2 branches covered.">    if (appProperties != null){</span>
<span class="fc" id="L217">      loadProperties( appProperties);</span>
    }

    //--- at last, the (rest of the) command line properties
<span class="fc" id="L221">    loadArgs(a);</span>

    // note that global path collection now happens from initClassLoader(), to
    // accommodate for deferred project initialization when explicitly setting Config entries

    //printEntries();
<span class="fc" id="L227">  }</span>

<span class="nc" id="L229">  private Config() {</span>
    // just interal, for reloading
<span class="nc" id="L231">  }</span>
  
  /**
   * single source Config constructor (does not process stack)
   * @param fileName - single properties filename to initialize from 
   */
<span class="nc" id="L237">  public Config (String fileName){</span>
<span class="nc" id="L238">    loadProperties(fileName);</span>
<span class="nc" id="L239">  }</span>

<span class="nc" id="L241">  public Config (Reader in){</span>
    try {
<span class="nc" id="L243">      load(in);</span>
<span class="nc" id="L244">    } catch (IOException iox){</span>
<span class="nc" id="L245">      exception(&quot;error reading data: &quot; + iox);</span>
<span class="nc" id="L246">    }</span>
<span class="nc" id="L247">  }</span>
  
  public static void enableLogging (boolean enableLogging){
<span class="fc" id="L250">    log = enableLogging;</span>
<span class="fc" id="L251">  }</span>

  public void log (String msg){
<span class="fc bfc" id="L254" title="All 2 branches covered.">    if (log){ // very simplisitc, but we might do more in the future</span>
<span class="fc" id="L255">      System.out.println(msg);</span>
    }
<span class="fc" id="L257">  }</span>


  String getAppPropertiesLocation(String[] args){
<span class="fc" id="L261">    String path = null;</span>

<span class="fc" id="L263">    path = getPathArg(args, &quot;app&quot;);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">    if (path == null){</span>
      // see if the first free arg is a *.jpf
<span class="fc" id="L266">      path = getAppArg(args);</span>
    }
    
<span class="fc" id="L269">    put(&quot;jpf.app&quot;, path);</span>

<span class="fc" id="L271">    return path;</span>
  }

  String getSitePropertiesLocation(String[] args, String appPropPath){
<span class="fc" id="L275">    String path = getPathArg(args, &quot;site&quot;);</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">    if (path == null){</span>
      // look into the app properties
      // NOTE: we might want to drop this in the future because it constitutes
      // a cyclic properties file dependency
<span class="fc bfc" id="L281" title="All 2 branches covered.">      if (appPropPath != null){</span>
<span class="fc" id="L282">        path = JPFSiteUtils.getMatchFromFile(appPropPath,&quot;site&quot;);</span>
      }

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">      if (path == null) {</span>
<span class="fc" id="L286">        File siteProps = JPFSiteUtils.getStandardSiteProperties();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (siteProps != null){</span>
<span class="nc" id="L288">          path = siteProps.getAbsolutePath();</span>
        }
      }
    }
    
<span class="fc" id="L293">    put(&quot;jpf.site&quot;, path);</span>

<span class="fc" id="L295">    return path;</span>
  }


  // watch out - this does not reset the computed paths!
  public Config reload() {
<span class="nc" id="L301">    log(&quot;reloading config&quot;);</span>

    // just reload all our sources
<span class="nc" id="L304">    Config newConfig = new Config();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">    for (Object src : sources){</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">      if (src instanceof File) {</span>
<span class="nc" id="L307">        newConfig.loadProperties(((File)src).getPath());</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">      } else if (src instanceof URL) {</span>
<span class="nc" id="L309">        newConfig.loadProperties((URL)src);</span>
      } else {
<span class="nc" id="L311">        log(&quot;don't know how to reload: &quot; + src);</span>
      }
<span class="nc" id="L313">    }</span>

    // now reload command line args on top of that
<span class="nc" id="L316">    newConfig.loadArgs(args);</span>
<span class="nc" id="L317">    newConfig.args = args;</span>
    
<span class="nc" id="L319">    return newConfig;</span>
  }

  public String[] getArgs() {
<span class="nc" id="L323">    return args;</span>
  }

  /*
   * note that matching args are expanded and stored here, to avoid any
   * discrepancy with value expansions (which are order-dependent)
   */
  protected String getPathArg (String[] args, String key){
<span class="fc" id="L331">    int keyLen = key.length();</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">    for (int i=0; i&lt;args.length; i++){</span>
<span class="fc" id="L334">      String a = args[i];</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">      if (a != null){</span>
<span class="fc" id="L336">        int len = a.length();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (len &gt; keyLen + 2){</span>
<span class="fc bfc" id="L338" title="All 4 branches covered.">          if (a.charAt(0) == '+' &amp;&amp; a.charAt(keyLen+1) == '='){</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (a.substring(1, keyLen+1).equals(key)){</span>
<span class="fc" id="L340">              String val = expandString(key, a.substring(keyLen+2));</span>
<span class="fc" id="L341">              args[i] = null; // processed</span>
<span class="fc" id="L342">              return val;</span>
            }
          }
        }
      }
    }

<span class="fc" id="L349">    return null;</span>
  }

  /*
   * if the first freeArg is a JPF application property filename, use this
   * as targetArg and set the &quot;jpf.app&quot; property accordingly
   */
  protected String getAppArg (String[] args){

<span class="fc bfc" id="L358" title="All 2 branches covered.">    for (int i=0; i&lt;args.length; i++){</span>
<span class="fc" id="L359">      String a = args[i];</span>
<span class="pc bpc" id="L360" title="2 of 4 branches missed.">      if (a != null &amp;&amp; a.length() &gt; 0){</span>
<span class="pc bpc" id="L361" title="1 of 3 branches missed.">        switch (a.charAt(0)) {</span>
<span class="fc" id="L362">          case '+': continue;</span>
<span class="nc" id="L363">          case '-': continue;</span>
          default:
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (a.endsWith(&quot;.jpf&quot;)){</span>
<span class="fc" id="L366">              String val = expandString(&quot;jpf.app&quot;, a);</span>
<span class="fc" id="L367">              args[i] = null; // processed</span>
<span class="fc" id="L368">              return val;</span>
            }
        }
      }
    }

<span class="fc" id="L374">    return null;</span>
  }


  protected void loadProperties (URL url){
<span class="nc" id="L379">    log(&quot;loading defaults from: &quot; + url);</span>

<span class="nc" id="L381">    InputStream is = null;</span>
    try {
<span class="nc" id="L383">      is = url.openStream();</span>
<span class="nc" id="L384">      load(is);</span>
<span class="nc" id="L385">      sources.add(url);</span>
<span class="nc" id="L386">    } catch (IOException iox){</span>
<span class="nc" id="L387">      log(&quot;error in input stream for: &quot; + url + &quot; : &quot; + iox.getMessage());</span>
    } finally {
<span class="nc bnc" id="L389" title="All 2 branches missed.">      if (is != null){</span>
        try {
<span class="nc" id="L391">          is.close();</span>
<span class="nc" id="L392">        } catch (IOException iox1){</span>
<span class="nc" id="L393">          log(&quot;error closing input stream for: &quot; + url + &quot; : &quot; + iox1.getMessage());</span>
<span class="nc" id="L394">        }</span>
      }
    }
<span class="nc" id="L397">  }</span>

  protected void setConfigPathProperties (String fileName){
<span class="fc" id="L400">    put(&quot;config&quot;, fileName);</span>
<span class="fc" id="L401">    int i = fileName.lastIndexOf(File.separatorChar);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">    if (i&gt;=0){</span>
<span class="fc" id="L403">      put(&quot;config_path&quot;, fileName.substring(0,i));</span>
    } else {
<span class="nc" id="L405">      put(&quot;config_path&quot;, &quot;.&quot;);</span>
    }
<span class="fc" id="L407">  }</span>


  protected boolean loadProperties (String fileName) {
<span class="pc bpc" id="L411" title="2 of 4 branches missed.">    if (fileName != null &amp;&amp; fileName.length() &gt; 0) {</span>
<span class="fc" id="L412">      FileInputStream is = null;</span>
      try {
<span class="fc" id="L414">        File f = new File(fileName);</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (f.isFile()) {</span>
<span class="fc" id="L416">          log(&quot;loading property file: &quot; + fileName);</span>

<span class="fc" id="L418">          setConfigPathProperties(f.getAbsolutePath());</span>
<span class="fc" id="L419">          sources.add(f);</span>
<span class="fc" id="L420">          is = new FileInputStream(f);</span>
<span class="fc" id="L421">          load(is);</span>
<span class="fc" id="L422">          return true;</span>
        } else {
<span class="nc" id="L424">          throw exception(&quot;property file does not exist: &quot; + f.getAbsolutePath());</span>
        }
<span class="fc" id="L426">      } catch (MissingRequiredKeyException rkx){</span>
        // Hmpff - control exception
<span class="fc" id="L428">        log(&quot;missing required key: &quot; + rkx.getMessage() + &quot;, skipping: &quot; + fileName);</span>
<span class="nc" id="L429">      } catch (IOException iex) {</span>
<span class="nc" id="L430">        throw exception(&quot;error reading properties: &quot; + fileName);</span>
      } finally {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (is != null){</span>
          try {
<span class="fc" id="L434">            is.close();</span>
<span class="nc" id="L435">          } catch (IOException iox1){</span>
<span class="nc" id="L436">            log(&quot;error closing input stream for file: &quot; + fileName);</span>
<span class="fc" id="L437">          }</span>
        }
      }
    }

<span class="fc" id="L442">    return false;</span>
  }


  /**
   * this holds the policy defining in which order we process directories
   * containing JPF projects (i.e. jpf.properties files)
   */
  protected void loadProjectProperties () {
    // this is the list of directories holding jpf.properties files that
    // have to be processed in order of entry (increasing priority)
<span class="fc" id="L453">    LinkedList&lt;File&gt; jpfDirs = new LinkedList&lt;File&gt;();</span>

    // deduce the JPF projects in use (at least jpf-core) from the CL which
    // defined this class
<span class="fc" id="L457">    addJPFdirsFromClasspath(jpfDirs);</span>

    // add all the site configured extension dirs (but NOT jpf-core)
<span class="fc" id="L460">    addJPFdirsFromSiteExtensions(jpfDirs);</span>

    // add the current dir, which has highest priority (this might bump up
    // a previous entry by reodering it - which includes jpf-core)
<span class="fc" id="L464">    addCurrentJPFdir(jpfDirs);</span>

    // now load all the jpf.property files we found in these dirs
    // (later loads can override previous settings)
<span class="fc bfc" id="L468" title="All 2 branches covered.">    for (File dir : jpfDirs){</span>
<span class="fc" id="L469">      loadProperties(new File(dir,&quot;jpf.properties&quot;).getAbsolutePath());</span>
<span class="fc" id="L470">    }</span>
<span class="fc" id="L471">  }</span>

  protected void appendPath (String pathKey, String key, String configPath){
<span class="nc" id="L474">    String[] paths = getStringArray(key);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">    if (paths != null){</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">      for (String e : paths) {</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">        if (!e.startsWith(&quot;${&quot;) || !e.startsWith(File.separator)) {</span>
<span class="nc" id="L478">          e = configPath + File.separatorChar + e;</span>
        }
<span class="nc" id="L480">        append(pathKey, e, PATH_SEPARATOR);</span>
      }
    }
<span class="nc" id="L483">  }</span>

  protected void addJPFdirs (List&lt;File&gt; jpfDirs, File dir){
<span class="fc bfc" id="L486" title="All 2 branches covered.">    while (dir != null) {</span>
<span class="fc" id="L487">      File jpfProp = new File(dir, &quot;jpf.properties&quot;);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">      if (jpfProp.isFile()) {</span>
<span class="fc" id="L489">        registerJPFdir(jpfDirs, dir);</span>
<span class="fc" id="L490">        return;       // we probably don't want recursion here</span>
      }
<span class="fc" id="L492">      dir = getParentFile(dir);</span>
<span class="fc" id="L493">    }</span>
<span class="fc" id="L494">  }</span>

  /**
   * add the current dir to the list of JPF components.
   * Note: this includes the core, so that we maintain the general
   * principle that the enclosing project takes precedence (imagine the opposite:
   * if we want to test a certain feature that is overridden by another extension
   * we don't know about)
   */
  protected void addCurrentJPFdir(List&lt;File&gt; jpfDirs){
<span class="fc" id="L504">    File dir = new File(System.getProperty(&quot;user.dir&quot;));</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">    while (dir != null) {</span>
<span class="fc" id="L506">      File jpfProp = new File(dir, &quot;jpf.properties&quot;);</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">      if (jpfProp.isFile()) {</span>
<span class="fc" id="L508">        registerJPFdir(jpfDirs, dir);</span>
<span class="fc" id="L509">        return;</span>
      }
<span class="nc" id="L511">      dir = getParentFile(dir);</span>
<span class="nc" id="L512">    }</span>
<span class="nc" id="L513">  }</span>

  protected void addJPFdirsFromClasspath(List&lt;File&gt; jpfDirs) {
<span class="fc" id="L516">    String cp = System.getProperty(&quot;java.class.path&quot;);</span>
<span class="fc" id="L517">    String[] cpEntries = cp.split(File.pathSeparator);</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">    for (String p : cpEntries) {</span>
<span class="fc" id="L520">      File f = new File(p);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">      File dir = f.isFile() ? getParentFile(f) : f;</span>

<span class="fc" id="L523">      addJPFdirs(jpfDirs, dir);</span>
    }
<span class="fc" id="L525">  }</span>

  protected void addJPFdirsFromSiteExtensions (List&lt;File&gt; jpfDirs){
<span class="fc" id="L528">    String[] extensions = getCompactStringArray(&quot;extensions&quot;);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">    if (extensions != null){</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">      for (String pn : extensions){</span>
<span class="fc" id="L531">        addJPFdirs( jpfDirs, new File(pn));</span>
      }
    }
<span class="fc" id="L534">  }</span>

  /**
   * the obvious part is that it only adds to the list if the file is absent
   * the not-so-obvious part is that it re-orders already present files
   * to maintain the priority
   */
  protected boolean registerJPFdir(List&lt;File&gt; list, File dir){
    try {
<span class="fc" id="L543">      dir = dir.getCanonicalFile();</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">      for (File e : list) {</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (e.equals(dir)) {</span>
<span class="fc" id="L547">          list.remove(e);</span>
<span class="fc" id="L548">          list.add(e);</span>
<span class="fc" id="L549">          return false;</span>
        }
<span class="nc" id="L551">      }</span>
<span class="nc" id="L552">    } catch (IOException iox) {</span>
<span class="nc" id="L553">      throw new JPFConfigException(&quot;illegal path spec: &quot; + dir);</span>
<span class="fc" id="L554">    }</span>
    
<span class="fc" id="L556">    list.add(dir);</span>
<span class="fc" id="L557">    return true;</span>
  }

<span class="fc" id="L560">  static File root = new File(File.separator);</span>

  protected File getParentFile(File f){
<span class="fc bfc" id="L563" title="All 2 branches covered.">    if (f == root){</span>
<span class="fc" id="L564">      return null;</span>
    } else {
<span class="fc" id="L566">      File parent = f.getParentFile();</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">      if (parent == null){</span>
<span class="fc" id="L568">        parent = new File(f.getAbsolutePath());</span>

<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        if (parent.getName().equals(root.getName())) {</span>
<span class="fc" id="L571">          return root;</span>
        } else {
<span class="nc" id="L573">          return parent;</span>
        }
      } else {
<span class="fc" id="L576">        return parent;</span>
      }
    }
  }


  /*
   * argument syntax:
   *          {'+'&lt;key&gt;['='&lt;val&gt;'] | '-'&lt;driver-arg&gt;} {&lt;free-arg&gt;}
   *
   * (1) null cmdLineArgs are ignored
   * (2) all config cmdLineArgs start with '+'
   * (3) if '=' is ommitted, a 'true' value is assumed
   * (4) if &lt;val&gt; is ommitted, a 'null' value is assumed
   * (5) no spaces around '='
   * (6) all '-' driver-cmdLineArgs are ignored
   */

  protected void loadArgs (String[] cmdLineArgs) {

<span class="fc bfc" id="L596" title="All 2 branches covered.">    for (int i=0; i&lt;cmdLineArgs.length; i++){</span>
<span class="fc" id="L597">      String a = cmdLineArgs[i];</span>

<span class="pc bpc" id="L599" title="1 of 4 branches missed.">      if (a != null &amp;&amp; a.length() &gt; 0){</span>
<span class="pc bpc" id="L600" title="1 of 3 branches missed.">        switch (a.charAt(0)){</span>
          case '+': // Config arg
<span class="fc" id="L602">            processArg(a.substring(1));</span>
<span class="fc" id="L603">            break;</span>

          case '-': // driver arg, ignore
<span class="nc" id="L606">            continue;</span>

          default:  // free (non property/option) cmdLineArgs to follow

<span class="fc" id="L610">            int n = cmdLineArgs.length - i;</span>
<span class="fc" id="L611">            freeArgs = new String[n];</span>
<span class="fc" id="L612">            System.arraycopy(cmdLineArgs, i, freeArgs, 0, n);</span>

<span class="fc" id="L614">            return;</span>
        }
      }
    }
<span class="fc" id="L618">  }</span>


  /*
   * this does not include the '+' prefix, just the 
   *     &lt;key&gt;[=[&lt;value&gt;]]
   */
  protected void processArg (String a) {

<span class="fc" id="L627">    int idx = a.indexOf(&quot;=&quot;);</span>

<span class="pc bpc" id="L629" title="1 of 2 branches missed.">    if (idx == 0){</span>
<span class="nc" id="L630">      throw new JPFConfigException(&quot;illegal option: &quot; + a);</span>
    }

<span class="fc bfc" id="L633" title="All 2 branches covered.">    if (idx &gt; 0) {</span>
<span class="fc" id="L634">      String key = a.substring(0, idx).trim();</span>
<span class="fc" id="L635">      String val = a.substring(idx + 1).trim();</span>

<span class="pc bpc" id="L637" title="1 of 2 branches missed.">      if (val.length() == 0){</span>
<span class="nc" id="L638">        val = null;</span>
      }

<span class="fc" id="L641">      setProperty(key, val);</span>

<span class="fc" id="L643">    } else {</span>
<span class="fc" id="L644">      setProperty(a.trim(), &quot;true&quot;);</span>
    }

<span class="fc" id="L647">  }</span>


  /**
   * replace string constants with global static objects
   */
  protected String normalize (String v) {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">    if (v == null){</span>
<span class="nc" id="L655">      return null; // ? maybe TRUE - check default loading of &quot;key&quot; or &quot;key=&quot;</span>
    }

    // trim leading and trailing blanks (at least Java 1.4.2 does not take care of trailing blanks)
<span class="fc" id="L659">    v = v.trim();</span>
    
    // true/false
<span class="fc bfc" id="L662" title="All 2 branches covered.">    if (&quot;true&quot;.equalsIgnoreCase(v)</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        || &quot;yes&quot;.equalsIgnoreCase(v)</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        || &quot;on&quot;.equalsIgnoreCase(v)) {</span>
<span class="fc" id="L665">      v = TRUE;</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">    } else if (&quot;false&quot;.equalsIgnoreCase(v)</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        || &quot;no&quot;.equalsIgnoreCase(v)</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">        || &quot;off&quot;.equalsIgnoreCase(v)) {</span>
<span class="fc" id="L669">      v = FALSE;</span>
    }

    // nil/null
<span class="fc bfc" id="L673" title="All 4 branches covered.">    if (&quot;nil&quot;.equalsIgnoreCase(v) || &quot;null&quot;.equalsIgnoreCase(v)){</span>
<span class="fc" id="L674">      v = null;</span>
    }
    
<span class="fc" id="L677">    return v;</span>
  }

  
  // our internal expander
  // Note that we need to know the key this came from, to handle recursive expansion
  protected String expandString (String key, String s) {
<span class="fc" id="L684">    int i, j = 0;</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">    if (s == null || s.length() == 0) {</span>
<span class="fc" id="L686">      return s;</span>
    }

<span class="fc bfc" id="L689" title="All 2 branches covered.">    while ((i = s.indexOf(&quot;${&quot;, j)) &gt;= 0) {</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">      if ((j = s.indexOf('}', i)) &gt; 0) {</span>
<span class="fc" id="L691">        String k = s.substring(i + 2, j);</span>
        String v;
        
<span class="pc bpc" id="L694" title="1 of 4 branches missed.">        if ((key != null) &amp;&amp; key.equals(k)) {</span>
          // that's expanding itself -&gt; use what is there
<span class="nc" id="L696">          v = getProperty(key);</span>
        } else {
          // refers to another key, which is already expanded, so this
          // can't get recursive (we expand during entry storage)
<span class="fc" id="L700">          v = getProperty(k);</span>
        }
        
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">        if (v == null) { // if we don't have it, fall back to system properties</span>
<span class="nc" id="L704">          v = System.getProperty(k);</span>
        }
        
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (v != null) {</span>
<span class="fc" id="L708">          s = s.substring(0, i) + v + s.substring(j + 1, s.length());</span>
<span class="fc" id="L709">          j = i + v.length();</span>
        } else {
<span class="nc" id="L711">          s = s.substring(0, i) + s.substring(j + 1, s.length());</span>
<span class="nc" id="L712">          j = i;</span>
        }
<span class="fc" id="L714">      }</span>
    }

<span class="fc" id="L717">    return s;    </span>
  }


  boolean loadPropertiesRecursive (String fileName){
    // save the current values of automatic properties
<span class="fc" id="L723">    String curConfig = (String)get(&quot;config&quot;);</span>
<span class="fc" id="L724">    String curConfigPath = (String)get(&quot;config_path&quot;);</span>

<span class="fc" id="L726">    File propFile = new File(fileName);</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">    if (!propFile.isAbsolute()){</span>
<span class="nc" id="L728">      propFile = new File(curConfigPath, fileName);</span>
    }
<span class="fc" id="L730">    String absPath = propFile.getAbsolutePath();</span>

<span class="pc bpc" id="L732" title="1 of 2 branches missed.">    if (!propFile.isFile()){</span>
<span class="nc" id="L733">      throw exception(&quot;property file does not exist: &quot; + absPath);</span>
    }

<span class="fc" id="L736">    boolean ret = loadProperties(absPath);</span>

    // restore the automatic properties
<span class="fc" id="L739">    super.put(&quot;config&quot;, curConfig);</span>
<span class="fc" id="L740">    super.put(&quot;config_path&quot;, curConfigPath);</span>

<span class="fc" id="L742">    return ret;</span>
  }

  void includePropertyFile(String key, String value){
<span class="fc" id="L746">    value = expandString(key, value);</span>
<span class="pc bpc" id="L747" title="2 of 4 branches missed.">    if (value != null &amp;&amp; value.length() &gt; 0){</span>
<span class="fc" id="L748">      loadPropertiesRecursive(value);</span>
    } else {
<span class="nc" id="L750">      throw exception(&quot;@include pathname argument missing&quot;);</span>
    }
<span class="fc" id="L752">  }</span>

  void includeCondPropertyFile(String key, String value, boolean keyPresent){
<span class="nc" id="L755">    value = expandString(key, value);</span>
<span class="nc bnc" id="L756" title="All 4 branches missed.">    if (value != null &amp;&amp; value.length() &gt; 0){</span>
      // check if it's a conditional &quot;@include_unless/if = ?key?pathName&quot;
<span class="nc bnc" id="L758" title="All 2 branches missed.">      if (value.charAt(0) == '?'){</span>
<span class="nc" id="L759">        int idx = value.indexOf('?', 1);</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (idx &gt; 1){</span>
<span class="nc" id="L761">          String k = value.substring(1, idx);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">          if (containsKey(k) == keyPresent){</span>
<span class="nc" id="L763">            String v = value.substring(idx+1);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            if (v.length() &gt; 0){</span>
<span class="nc" id="L765">              loadPropertiesRecursive(v);</span>
            } else {
<span class="nc" id="L767">              throw exception(&quot;@include_unless pathname argument missing (?&lt;key&gt;?&lt;pathName&gt;)&quot;);</span>
            }
          }

<span class="nc" id="L771">        } else {</span>
<span class="nc" id="L772">          throw exception(&quot;malformed @include_unless argument (?&lt;key&gt;?&lt;pathName&gt;), found: &quot; + value);</span>
        }
<span class="nc" id="L774">      } else {</span>
<span class="nc" id="L775">        throw exception(&quot;malformed @include_unless argument (?&lt;key&gt;?&lt;pathName&gt;), found: &quot; + value);</span>
      }
    } else {
<span class="nc" id="L778">      throw exception(&quot;@include_unless missing ?&lt;key&gt;?&lt;pathName&gt; argument&quot;);</span>
    }
<span class="nc" id="L780">  }</span>


  void includeProjectPropertyFile (String projectId){
<span class="nc" id="L784">    String projectPath = getString(projectId);</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">    if (projectPath != null){</span>
<span class="nc" id="L786">      File projectProps = new File(projectPath, &quot;jpf.properties&quot;);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">      if (projectProps.isFile()){</span>
<span class="nc" id="L788">        loadPropertiesRecursive(projectProps.getAbsolutePath());</span>

      } else {
<span class="nc" id="L791">        throw exception(&quot;project properties not found: &quot; + projectProps.getAbsolutePath());</span>
      }

<span class="nc" id="L794">    } else {</span>
<span class="nc" id="L795">      throw exception(&quot;unknown project id (check site.properties): &quot; + projectId);</span>
    }
<span class="nc" id="L797">  }</span>

  // we override this so that we can handle expansion for both key and value
  // (value expansion can be recursive, i.e. refer to itself)
  @Override
  public Object put (Object keyObject, Object valueObject){

<span class="pc bpc" id="L804" title="1 of 2 branches missed.">    if (keyObject == null){</span>
<span class="nc" id="L805">      throw exception(&quot;no null keys allowed&quot;);</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">    } else if (!(keyObject instanceof String)){</span>
<span class="nc" id="L807">      throw exception(&quot;only String keys allowed, got: &quot; + keyObject);</span>
    }
<span class="pc bpc" id="L809" title="1 of 4 branches missed.">    if (valueObject != null &amp;&amp; !(valueObject instanceof String)){</span>
<span class="nc" id="L810">      throw exception(&quot;only String or null values allowed, got: &quot; + valueObject);</span>
    }

<span class="fc" id="L813">    String key = (String)keyObject;</span>
<span class="fc" id="L814">    String value = (String)valueObject;</span>

<span class="pc bpc" id="L816" title="1 of 2 branches missed.">    if (key.length() == 0){</span>
<span class="nc" id="L817">      throw exception(&quot;no empty keys allowed&quot;);</span>
    }

<span class="fc bfc" id="L820" title="All 2 branches covered.">    if (key.charAt(0) == KEY_PREFIX){</span>
<span class="fc" id="L821">      processPseudoProperty( key, value);</span>
<span class="fc" id="L822">      return null; // no value it replaces</span>

    } else {
      // finally, a real key/value pair to add (or remove) - expand and store
<span class="fc" id="L826">      String k = expandString(null, key);</span>

<span class="fc bfc" id="L828" title="All 2 branches covered.">      if (!(value == null)) { // add or overwrite entry</span>
<span class="fc" id="L829">        String v = value;</span>

<span class="fc bfc" id="L831" title="All 2 branches covered.">        if (k.charAt(k.length() - 1) == '+') { // the append hack</span>
<span class="fc" id="L832">          k = k.substring(0, k.length() - 1);</span>
<span class="fc" id="L833">          return append(k, v, null);</span>

<span class="pc bpc" id="L835" title="1 of 2 branches missed.">        } else if (k.charAt(0) == '+') { // the prepend hack</span>
<span class="nc" id="L836">          k = k.substring(1);</span>
<span class="nc" id="L837">          return prepend(k, v, null);</span>

        } else { // normal value set
<span class="fc" id="L840">          v = normalize(expandString(k, v));</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">          if (v != null){</span>
<span class="fc" id="L842">            return setKey(k, v);</span>
          } else {
<span class="fc" id="L844">            return removeKey(k);</span>
          }
        }

      } else { // setting a null value removes the entry
<span class="fc" id="L849">        return removeKey(k);</span>
      }
    }
  }
  
  protected void processPseudoProperty( String key, String value){
<span class="fc bfc" id="L855" title="All 2 branches covered.">    if (REQUIRES_KEY.equals(key)) {</span>
      // shortcircuit loading of property files - used to enforce order
      // of properties, e.g. to model dependencies
<span class="fc bfc" id="L858" title="All 2 branches covered.">      for (String reqKey : split(value)) {</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">        if (!containsKey(reqKey)) {</span>
<span class="fc" id="L860">          throw new MissingRequiredKeyException(reqKey);</span>
        }
      }

<span class="pc bpc" id="L864" title="1 of 2 branches missed.">    } else if (INCLUDE_KEY.equals(key)) {</span>
<span class="fc" id="L865">      includePropertyFile(key, value);</span>
      
<span class="nc bnc" id="L867" title="All 2 branches missed.">    } else if (INCLUDE_UNLESS_KEY.equals(key)) {</span>
<span class="nc" id="L868">      includeCondPropertyFile(key, value, false);</span>
      
<span class="nc bnc" id="L870" title="All 2 branches missed.">    } else if (INCLUDE_IF_KEY.equals(key)) {</span>
<span class="nc" id="L871">      includeCondPropertyFile(key, value, true);</span>
      
<span class="nc bnc" id="L873" title="All 2 branches missed.">    } else if (USING_KEY.equals(key)) {</span>
      // check if corresponding jpf.properties has already been loaded. If yes, skip
<span class="nc bnc" id="L875" title="All 2 branches missed.">      if (!haveSeenProjectProperty(value)){</span>
<span class="nc" id="L876">        includeProjectPropertyFile(value);</span>
      }
      
    } else {
<span class="nc" id="L880">      throw exception(&quot;unknown keyword: &quot; + key);</span>
    }
<span class="fc" id="L882">  }</span>

  protected boolean haveSeenProjectProperty (String key){
<span class="nc" id="L885">    String pn = getString(key);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">    if (pn == null){</span>
<span class="nc" id="L887">      return false;</span>
    } else {
<span class="nc" id="L889">      return sources.contains( new File( pn, &quot;jpf.properties&quot;));</span>
    }
  }
  
  private Object setKey (String k, String v){
<span class="fc" id="L894">    Object oldValue = put0(k, v);</span>
<span class="fc" id="L895">    notifyPropertyChangeListeners(k, (String) oldValue, v);</span>
<span class="fc" id="L896">    return oldValue;</span>
  }

  private Object removeKey (String k){
<span class="fc" id="L900">    Object oldValue = super.get(k);</span>
<span class="fc" id="L901">    remove0(k);</span>
<span class="fc" id="L902">    notifyPropertyChangeListeners(k, (String) oldValue, null);</span>
<span class="fc" id="L903">    return oldValue;</span>
  }

  private Object put0 (String k, Object v){
<span class="fc" id="L907">    entrySequence.add(k);</span>
<span class="fc" id="L908">    return super.put(k, v);</span>
  }

  private Object remove0 (String k){
<span class="fc" id="L912">    entrySequence.add(k);</span>
<span class="fc" id="L913">    return super.remove(k);</span>
  }

  public String prepend (String key, String value, String separator) {
<span class="nc" id="L917">    String oldValue = getProperty(key);</span>
<span class="nc" id="L918">    value = normalize( expandString(key, value));</span>

<span class="nc" id="L920">    append0(key, oldValue, value, oldValue, separator);</span>

<span class="nc" id="L922">    return oldValue;</span>
  }

  public String append (String key, String value, String separator) {
<span class="fc" id="L926">    String oldValue = getProperty(key);</span>
<span class="fc" id="L927">    value = normalize( expandString(key, value));</span>

<span class="fc" id="L929">    append0(key, oldValue, oldValue, value, separator);</span>

<span class="fc" id="L931">    return oldValue;</span>
  }


  private void append0 (String key, String oldValue, String a, String b, String separator){
    String newValue;

<span class="fc bfc" id="L938" title="All 2 branches covered.">    if (a != null){</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">      if (b != null) {</span>
<span class="fc" id="L940">        StringBuilder sb = new StringBuilder(a);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">        if (separator != null) {</span>
<span class="fc" id="L942">          sb.append(separator);</span>
        }
<span class="fc" id="L944">        sb.append(b);</span>
<span class="fc" id="L945">        newValue = sb.toString();</span>

<span class="fc" id="L947">      } else { // b==null : nothing to append</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">        if (oldValue == a){ // using reference compare is intentional here</span>
<span class="nc" id="L949">          return; // no change</span>
        } else {
<span class="nc" id="L951">          newValue = a;</span>
        }
      }

    } else { // a==null : nothing to append to
<span class="pc bpc" id="L956" title="2 of 4 branches missed.">      if (oldValue == b || b == null){  // using reference compare is intentional here</span>
<span class="nc" id="L957">        return; // no change</span>
      } else {
<span class="fc" id="L959">        newValue = b;</span>
      }
    }

    // if we get here, we have a newValue that differs from oldValue
<span class="fc" id="L964">    put0(key, newValue);</span>
<span class="fc" id="L965">    notifyPropertyChangeListeners(key, oldValue, newValue);</span>
<span class="fc" id="L966">  }</span>

  protected String append (String key, String value) {
<span class="fc" id="L969">    return append(key, value, LIST_SEPARATOR); // append with our standard list separator</span>
  }

  /**
   * check if we have a key.index entry. If not, check the non-indexed key. If no
   * key found return null
   * This simplifies clients that can have process id indexed properties
   */
  public String getIndexableKey (String key, int index){
<span class="fc" id="L978">    String k = key + '.' + index;</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">    if (containsKey(k)){</span>
<span class="nc" id="L980">      return k;</span>
    } else {
<span class="fc bfc" id="L982" title="All 2 branches covered.">      if (containsKey(key)){</span>
<span class="fc" id="L983">        return key;</span>
      }
    }
    
<span class="fc" id="L987">    return null; // neither indexed nor non-indexed key in dictionary</span>
  }

  public void setClassLoader (ClassLoader newLoader){
<span class="nc" id="L991">    loader = newLoader;</span>
<span class="nc" id="L992">  }</span>

  public ClassLoader getClassLoader (){
<span class="fc" id="L995">    return loader;</span>
  }

  public boolean hasSetClassLoader (){
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">    return Config.class.getClassLoader() != loader;</span>
  }

  public JPFClassLoader initClassLoader (ClassLoader parent) {
<span class="fc" id="L1003">    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>

    // we prefer to call this here automatically instead of allowing
    // explicit collectGlobalPath() calls because (a) this could not preserve
    // initial path settings, and (b) setting it *after* the JPFClassLoader got
    // installed won't work (would have to add URLs explicitly, or would have
    // to create a new JPFClassLoader, which then conflicts with classes already
    // defined by the previous one)
<span class="fc" id="L1011">    collectGlobalPaths();</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">    if (log){</span>
<span class="nc" id="L1013">      log(&quot;collected native_classpath=&quot; + get(&quot;native_classpath&quot;));</span>
<span class="nc" id="L1014">      log(&quot;collected native_libraries=&quot; + get(&quot;native_libraries&quot;));</span>
    }


<span class="fc" id="L1018">    String[] cp = getCompactStringArray(&quot;native_classpath&quot;);</span>
<span class="fc" id="L1019">    cp = FileUtils.expandWildcards(cp);</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">    for (String e : cp) {</span>
<span class="fc" id="L1021">      list.add(e);</span>
    }
<span class="fc" id="L1023">    URL[] urls = FileUtils.getURLs(list);</span>

<span class="fc" id="L1025">    String[] nativeLibs = getCompactStringArray(&quot;native_libraries&quot;);</span>

    JPFClassLoader cl;
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">    if (parent instanceof JPFClassLoader){ // no need to create a new one, just initialize</span>
<span class="nc" id="L1029">      cl = (JPFClassLoader)parent;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">      for (URL url : urls){</span>
<span class="nc" id="L1031">        cl.addURL(url);</span>
      }
<span class="nc" id="L1033">      cl.setNativeLibs(nativeLibs);</span>
      
    } else {    
<span class="fc" id="L1036">      cl = new JPFClassLoader( urls, nativeLibs, parent);</span>
    }
    
<span class="fc" id="L1039">    loader = cl;</span>
<span class="fc" id="L1040">    return cl;</span>
  }

  /**
   * has to be called if 'native_classpath' gets explicitly changed
   * USE WITH CARE - if this is messed up, it is hard to debug
   */
  public void updateClassLoader (){
<span class="nc bnc" id="L1048" title="All 4 branches missed.">    if (loader != null &amp;&amp; loader instanceof JPFClassLoader){</span>
<span class="nc" id="L1049">      JPFClassLoader jpfCl = (JPFClassLoader)loader;</span>
            
<span class="nc" id="L1051">      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1052">      String[] cp = getCompactStringArray(&quot;native_classpath&quot;);</span>
<span class="nc" id="L1053">      cp = FileUtils.expandWildcards(cp);</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">      for (String e : cp) {</span>
<span class="nc" id="L1055">        URL url = FileUtils.getURL(e);</span>
<span class="nc" id="L1056">        jpfCl.addURL(url); // this does not add if already present</span>
      }

<span class="nc" id="L1059">      String[] nativeLibs = getCompactStringArray(&quot;native_libraries&quot;);</span>
<span class="nc" id="L1060">      jpfCl.setNativeLibs(nativeLibs);</span>
    }
<span class="nc" id="L1062">  }</span>
  

  //------------------------------ public methods - the Config API


  public String[] getEntrySequence () {
    // whoever gets this might add/append/remove items, so we have to
    // avoid ConcurrentModificationExceptions
<span class="fc" id="L1071">    return entrySequence.toArray(new String[entrySequence.size()]);</span>
  }

  public void addChangeListener (ConfigChangeListener l) {
<span class="fc bfc" id="L1075" title="All 2 branches covered.">    if (changeListeners == null) {</span>
<span class="fc" id="L1076">      changeListeners = new ArrayList&lt;ConfigChangeListener&gt;();</span>
<span class="fc" id="L1077">      changeListeners.add(l);</span>
    } else {
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">      if (!changeListeners.contains(l)) {</span>
<span class="fc" id="L1080">        changeListeners.add(l);</span>
      }
    }
<span class="fc" id="L1083">  }</span>
  
  public void removeChangeListener (ConfigChangeListener l) {
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">    if (changeListeners != null) {</span>
<span class="fc" id="L1087">      changeListeners.remove(l);</span>
      
<span class="fc bfc" id="L1089" title="All 2 branches covered.">      if (changeListeners.size() == 0) {</span>
<span class="fc" id="L1090">        changeListeners = null;</span>
      }
    }
<span class="fc" id="L1093">  }</span>
  
  // this shouldn't really be public but only accessible to JPF
  public void jpfRunTerminated() {
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">    if (changeListeners != null) {</span>
      // note we can't use the standard list iterator here because the sole purpose
      // of having this notification is to remove the listener from the list during its enumeration
      // which would give us ConcurrentModificationExceptions
<span class="fc" id="L1101">      ArrayList&lt;ConfigChangeListener&gt; list = (ArrayList&lt;ConfigChangeListener&gt;)changeListeners.clone();</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">      for (ConfigChangeListener l : list) {</span>
<span class="fc" id="L1103">        l.jpfRunTerminated(this);</span>
<span class="fc" id="L1104">      }</span>
    }
<span class="fc" id="L1106">  }</span>
  
  public JPFException exception (String msg) {
<span class="nc" id="L1109">    String context = getString(&quot;config&quot;);</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">    if (context != null){</span>
<span class="nc" id="L1111">      msg = &quot;error in &quot; + context + &quot; : &quot; + msg;</span>
    }

<span class="nc" id="L1114">    return new JPFConfigException(msg);</span>
  }

  public void throwException(String msg) {
<span class="nc" id="L1118">    throw new JPFConfigException(msg);</span>
  }

  /**
   * return any command line args that are not options or properties
   * (this usually contains the application class and arguments)
   */
  public String[] getFreeArgs(){
<span class="fc" id="L1126">    return freeArgs;</span>
  } 

  //--- special keys
  
  /*
   * target and its associated keys (target.args, target.entry) are now
   * just ordinary key/value pairs and only here as convenience methods
   * for JPF drivers/shells so that you don't have to remember the key names
   * 
   * NOTE - this does only work for a SingleProcessVM, and only has the
   * desired effect before the JPF object is created
   */
  
  public void setTarget (String clsName) {
<span class="nc" id="L1141">    put(&quot;target&quot;, clsName);</span>
<span class="nc" id="L1142">  }</span>
  public String getTarget(){
<span class="nc" id="L1144">    return getString(&quot;target&quot;);</span>
  }
  
  public void setTargetArgs (String[] args) {
<span class="nc" id="L1148">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1149">    int i=0;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">    for (String a : args){</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">      if (i++ &gt; 0){</span>
<span class="nc" id="L1152">        sb.append(',');</span>
      }
<span class="nc" id="L1154">      sb.append(a);</span>
    }
<span class="nc" id="L1156">    put(&quot;target.args&quot;, sb.toString());</span>
<span class="nc" id="L1157">  }</span>
  public String[] getTargetArgs(){
<span class="nc" id="L1159">    String[] a = getStringArray(&quot;target.args&quot;);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">    if (a == null){</span>
<span class="nc" id="L1161">      return new String[0];</span>
    } else {
<span class="nc" id="L1163">      return a;</span>
    }
  }
  
  public void setTargetEntry (String mthName) {
<span class="nc" id="L1168">    put(&quot;target.entry&quot;, mthName);</span>
<span class="nc" id="L1169">  }</span>
  public String getTargetEntry(){
<span class="nc" id="L1171">    return getString(&quot;target.entry&quot;);</span>
  }
  
  
  //----------------------- type specific accessors

  public boolean getBoolean(String key) {
<span class="fc" id="L1178">    String v = getProperty(key);</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">    return (v == TRUE);</span>
  }

  public boolean getBoolean(String key, boolean def) {
<span class="fc" id="L1183">    String v = getProperty(key);</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">    if (v != null) {</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">      return (v == TRUE);</span>
    } else {
<span class="fc" id="L1187">      return def;</span>
    }
  }

  /**
   * for a given &lt;baseKey&gt;, check if there are corresponding
   * values for keys &lt;baseKey&gt;.0 ... &lt;baseKey&gt;.&lt;maxSize&gt;
   * If a value is found, store it in an array at the respective index
   *
   * @param baseKey String with base key without trailing '.'
   * @param maxSize maximum size of returned value array
   * @return trimmed array with String values found in dictionary
   */
  public String[] getStringEnumeration (String baseKey, int maxSize) {
<span class="fc" id="L1201">    String[] arr = new String[maxSize];</span>
<span class="fc" id="L1202">    int max=-1;</span>

<span class="fc" id="L1204">    StringBuilder sb = new StringBuilder(baseKey);</span>
<span class="fc" id="L1205">    sb.append('.');</span>
<span class="fc" id="L1206">    int len = baseKey.length()+1;</span>

<span class="fc bfc" id="L1208" title="All 2 branches covered.">    for (int i=0; i&lt;maxSize; i++) {</span>
<span class="fc" id="L1209">      sb.setLength(len);</span>
<span class="fc" id="L1210">      sb.append(i);</span>

<span class="fc" id="L1212">      String v = getString(sb.toString());</span>
<span class="fc bfc" id="L1213" title="All 2 branches covered.">      if (v != null) {</span>
<span class="fc" id="L1214">        arr[i] = v;</span>
<span class="fc" id="L1215">        max = i;</span>
      }
    }

<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">    if (max &gt;= 0) {</span>
<span class="fc" id="L1220">      max++;</span>
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">      if (max &lt; maxSize) {</span>
<span class="fc" id="L1222">        String[] a = new String[max];</span>
<span class="fc" id="L1223">        System.arraycopy(arr,0,a,0,max);</span>
<span class="fc" id="L1224">        return a;</span>
      } else {
<span class="nc" id="L1226">        return arr;</span>
      }
    } else {
<span class="nc" id="L1229">      return null;</span>
    }
  }

  public String[] getKeysStartingWith (String prefix){
<span class="fc" id="L1234">    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>

<span class="fc bfc" id="L1236" title="All 2 branches covered.">    for (Enumeration e = keys(); e.hasMoreElements(); ){</span>
<span class="fc" id="L1237">      String k = e.nextElement().toString();</span>
<span class="fc bfc" id="L1238" title="All 2 branches covered.">      if (k.startsWith(prefix)){</span>
<span class="fc" id="L1239">        list.add(k);</span>
      }
<span class="fc" id="L1241">    }</span>

<span class="fc" id="L1243">    return list.toArray(new String[list.size()]);</span>
  }

  public String[] getKeyComponents (String key){
<span class="fc" id="L1247">    return key.split(&quot;\\.&quot;);</span>
  }

  public int[] getIntArray (String key) throws JPFConfigException {
<span class="fc" id="L1251">    String v = getProperty(key);</span>

<span class="fc bfc" id="L1253" title="All 2 branches covered.">    if (v != null) {</span>
<span class="fc" id="L1254">      String[] sa = split(v);</span>
<span class="fc" id="L1255">      int[] a = new int[sa.length];</span>
<span class="fc" id="L1256">      int i = 0;</span>
      try {
<span class="fc bfc" id="L1258" title="All 2 branches covered.">        for (; i&lt;sa.length; i++) {</span>
<span class="fc" id="L1259">          String s = sa[i];</span>
          int val;
<span class="fc bfc" id="L1261" title="All 2 branches covered.">          if (s.startsWith(&quot;0x&quot;)){</span>
<span class="fc" id="L1262">            val = Integer.parseInt(s.substring(2),16); </span>
          } else {
<span class="fc" id="L1264">            val = Integer.parseInt(s);</span>
          }
<span class="fc" id="L1266">          a[i] = val;</span>
        }
<span class="fc" id="L1268">        return a;</span>
<span class="nc" id="L1269">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1270">        throw new JPFConfigException(&quot;illegal int[] element in '&quot; + key + &quot;' = \&quot;&quot; + sa[i] + '&quot;');</span>
      }
    } else {
<span class="fc" id="L1273">      return null;</span>
    }
  }
  public int[] getIntArray (String key, int... defaultValues){
<span class="fc" id="L1277">    int[] val = getIntArray(key);</span>
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">    if (val == null){</span>
<span class="fc" id="L1279">      return defaultValues;</span>
    } else {
<span class="nc" id="L1281">      return val;</span>
    }
  }

  public long getDuration (String key, long defValue) {
<span class="fc" id="L1286">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1287" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L1288">      long d = 0;</span>

<span class="nc bnc" id="L1290" title="All 2 branches missed.">      if (v.indexOf(':') &gt; 0){</span>
<span class="nc" id="L1291">        String[] a = v.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (a.length &gt; 3){</span>
          //log.severe(&quot;illegal duration: &quot; + key + &quot;=&quot; + v);
<span class="nc" id="L1294">          return defValue;</span>
        }
<span class="nc" id="L1296">        int m = 1000;</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        for (int i=a.length-1; i&gt;=0; i--, m*=60){</span>
          try {
<span class="nc" id="L1299">            int n = Integer.parseInt(a[i]);</span>
<span class="nc" id="L1300">            d += m*n;</span>
<span class="nc" id="L1301">          } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1302">            throw new JPFConfigException(&quot;illegal duration element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
<span class="nc" id="L1303">          }</span>
        }

<span class="nc" id="L1306">      } else {</span>
        try {
<span class="nc" id="L1308">          d = Long.parseLong(v);</span>
<span class="nc" id="L1309">        } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1310">          throw new JPFConfigException(&quot;illegal duration element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
<span class="nc" id="L1311">        }</span>
      }

<span class="nc" id="L1314">      return d;</span>
    }

<span class="fc" id="L1317">    return defValue;</span>
  }

  public int getInt(String key) {
<span class="fc" id="L1321">    return getInt(key, 0);</span>
  }

  public int getInt(String key, int defValue) {
<span class="fc" id="L1325">    String v = getProperty(key);</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">    if (v != null) {</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">      if (MAX.equals(v)){</span>
<span class="fc" id="L1328">        return Integer.MAX_VALUE;</span>
      } else {
        try {
<span class="fc" id="L1331">          return Integer.parseInt(v);</span>
<span class="nc" id="L1332">        } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1333">          throw new JPFConfigException(&quot;illegal int element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
        }
      }
    }

<span class="fc" id="L1338">    return defValue;</span>
  }

  public long getLong(String key) {
<span class="nc" id="L1342">    return getLong(key, 0L);</span>
  }

  public long getLong(String key, long defValue) {
<span class="fc" id="L1346">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">      if (MAX.equals(v)){</span>
<span class="nc" id="L1349">        return Long.MAX_VALUE;</span>
      } else {
        try {
<span class="nc" id="L1352">          return Long.parseLong(v);</span>
<span class="nc" id="L1353">        } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1354">          throw new JPFConfigException(&quot;illegal long element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
        }
      }
    }

<span class="fc" id="L1359">    return defValue;</span>
  }

  public long[] getLongArray (String key) throws JPFConfigException {
<span class="fc" id="L1363">    String v = getProperty(key);</span>

<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L1366">      String[] sa = split(v);</span>
<span class="nc" id="L1367">      long[] a = new long[sa.length];</span>
<span class="nc" id="L1368">      int i = 0;</span>
      try {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        for (; i&lt;sa.length; i++) {</span>
<span class="nc" id="L1371">          a[i] = Long.parseLong(sa[i]);</span>
        }
<span class="nc" id="L1373">        return a;</span>
<span class="nc" id="L1374">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1375">        throw new JPFConfigException(&quot;illegal long[] element in &quot; + key + &quot; = &quot; + sa[i]);</span>
      }
    } else {
<span class="fc" id="L1378">      return null;</span>
    }
  }

  public long[] getLongArray (String key, long... defaultValues){
<span class="fc" id="L1383">    long[] val = getLongArray(key);</span>
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">    if (val != null){</span>
<span class="nc" id="L1385">      return val;</span>
    } else {
<span class="fc" id="L1387">      return defaultValues;</span>
    } 
  }

  public float getFloat (String key) {
<span class="nc" id="L1392">    return getFloat(key, 0.0f);</span>
  }

  public float getFloat (String key, float defValue) {
<span class="nc" id="L1396">    String v = getProperty(key);</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L1399">        return Float.parseFloat(v);</span>
<span class="nc" id="L1400">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1401">        throw new JPFConfigException(&quot;illegal float element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
      }
    }

<span class="nc" id="L1405">    return defValue;</span>
  }
  
  public float[] getFloatArray (String key) throws JPFConfigException {
<span class="fc" id="L1409">    String v = getProperty(key);</span>

<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L1412">      String[] sa = split(v);</span>
<span class="nc" id="L1413">      float[] a = new float[sa.length];</span>
<span class="nc" id="L1414">      int i = 0;</span>
      try {
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        for (; i&lt;sa.length; i++) {</span>
<span class="nc" id="L1417">          a[i] = Float.parseFloat(sa[i]);</span>
        }
<span class="nc" id="L1419">        return a;</span>
<span class="nc" id="L1420">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1421">        throw new JPFConfigException(&quot;illegal float[] element in &quot; + key + &quot; = &quot; + sa[i]);</span>
      }
    } else {
<span class="fc" id="L1424">      return null;</span>
    }
  }
  public float[] getFloatArray (String key, float... defaultValues){
<span class="fc" id="L1428">    float[] v = getFloatArray( key);</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">    if (v != null){</span>
<span class="nc" id="L1430">      return v;</span>
    } else {
<span class="fc" id="L1432">      return defaultValues;</span>
    }
  }
  
  
  public double getDouble (String key) {
<span class="nc" id="L1438">    return getDouble(key, 0.0);</span>
  }

  public double getDouble (String key, double defValue) {
<span class="fc" id="L1442">    String v = getProperty(key);</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">    if (v != null) {</span>
      try {
<span class="fc" id="L1445">        return Double.parseDouble(v);</span>
<span class="nc" id="L1446">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1447">        throw new JPFConfigException(&quot;illegal double element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
      }
    }

<span class="fc" id="L1451">    return defValue;</span>
  }

  public double[] getDoubleArray (String key) throws JPFConfigException {
<span class="fc" id="L1455">    String v = getProperty(key);</span>

<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L1458">      String[] sa = split(v);</span>
<span class="nc" id="L1459">      double[] a = new double[sa.length];</span>
<span class="nc" id="L1460">      int i = 0;</span>
      try {
<span class="nc bnc" id="L1462" title="All 2 branches missed.">        for (; i&lt;sa.length; i++) {</span>
<span class="nc" id="L1463">          a[i] = Double.parseDouble(sa[i]);</span>
        }
<span class="nc" id="L1465">        return a;</span>
<span class="nc" id="L1466">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1467">        throw new JPFConfigException(&quot;illegal double[] element in &quot; + key + &quot; = &quot; + sa[i]);</span>
      }
    } else {
<span class="fc" id="L1470">      return null;</span>
    }
  }
  public double[] getDoubleArray (String key, double... defaultValues){
<span class="fc" id="L1474">    double[] v = getDoubleArray( key);</span>
<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">    if (v != null){</span>
<span class="nc" id="L1476">      return v;</span>
    } else {
<span class="fc" id="L1478">      return defaultValues;</span>
    }
  }

  public &lt;T extends Enum&lt;T&gt;&gt; T getEnum( String key, T[] values, T defValue){
<span class="fc" id="L1483">    String v = getProperty(key);</span>

<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">    if (v != null){</span>
<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">      for (T t : values){</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">        if (v.equalsIgnoreCase(t.name())){</span>
<span class="fc" id="L1488">          return t;</span>
        }
      }
      
<span class="nc" id="L1492">      throw new JPFConfigException(&quot;unknown enum value for &quot; + key + &quot; = &quot; + v);</span>
      
    } else {
<span class="nc" id="L1495">      return defValue;</span>
    }
  }

  public String getString(String key) {
<span class="fc" id="L1500">    return getProperty(key);</span>
  }

  public String getString(String key, String defValue) {
<span class="fc" id="L1504">    String s = getProperty(key);</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">    if (s != null) {</span>
<span class="fc" id="L1506">      return s;</span>
    } else {
<span class="fc" id="L1508">      return defValue;</span>
    }
  }

  /**
   * return memory size in bytes, or 'defValue' if not in dictionary. Encoding
   * can have a 'M' or 'k' postfix, values have to be positive integers (decimal
   * notation)
   */
  public long getMemorySize(String key, long defValue) {
<span class="fc" id="L1518">    String v = getProperty(key);</span>
<span class="fc" id="L1519">    long sz = defValue;</span>

<span class="fc bfc" id="L1521" title="All 2 branches covered.">    if (v != null) {</span>
<span class="fc" id="L1522">      int n = v.length() - 1;</span>
      try {
<span class="fc" id="L1524">        char c = v.charAt(n);</span>

<span class="pc bpc" id="L1526" title="3 of 4 branches missed.">        if ((c == 'M') || (c == 'm')) {</span>
<span class="fc" id="L1527">          sz = Long.parseLong(v.substring(0, n)) &lt;&lt; 20;</span>
<span class="nc bnc" id="L1528" title="All 4 branches missed.">        } else if ((c == 'K') || (c == 'k')) {</span>
<span class="nc" id="L1529">          sz = Long.parseLong(v.substring(0, n)) &lt;&lt; 10;</span>
        } else {
<span class="nc" id="L1531">          sz = Long.parseLong(v);</span>
        }

<span class="nc" id="L1534">      } catch (NumberFormatException nfx) {</span>
<span class="nc" id="L1535">        throw new JPFConfigException(&quot;illegal memory size element in '&quot; + key + &quot;' = \&quot;&quot; + v + '&quot;');</span>
<span class="fc" id="L1536">      }</span>
    }

<span class="fc" id="L1539">    return sz;</span>
  }

  public HashSet&lt;String&gt; getStringSet(String key){
<span class="fc" id="L1543">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1544" title="2 of 4 branches missed.">    if (v != null &amp;&amp; (v.length() &gt; 0)) {</span>
<span class="fc" id="L1545">      HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L1546" title="All 2 branches covered.">      for (String s : split(v)) {</span>
<span class="fc" id="L1547">        hs.add(s);</span>
      }
<span class="fc" id="L1549">      return hs;</span>
    }

<span class="nc" id="L1552">    return null;</span>
    
  }
  
  public HashSet&lt;String&gt; getNonEmptyStringSet(String key){
<span class="fc" id="L1557">    HashSet&lt;String&gt; hs = getStringSet(key);</span>
<span class="pc bpc" id="L1558" title="2 of 4 branches missed.">    if (hs != null &amp;&amp; hs.isEmpty()) {</span>
<span class="nc" id="L1559">      return null;</span>
    } else {
<span class="fc" id="L1561">      return hs;</span>
    }
  }
    
  public String[] getStringArray(String key) {
<span class="fc" id="L1566">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1567" title="1 of 4 branches missed.">    if (v != null &amp;&amp; (v.length() &gt; 0)) {</span>
<span class="fc" id="L1568">      return split(v);</span>
    }

<span class="fc" id="L1571">    return null;</span>
  }

  public String[] getStringArray(String key, char[] delims) {
<span class="fc" id="L1575">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1576" title="2 of 4 branches missed.">    if (v != null &amp;&amp; (v.length() &gt; 0)) {</span>
<span class="fc" id="L1577">      return split(v,delims);</span>
    }

<span class="nc" id="L1580">    return null;</span>
  }

  public String[] getCompactTrimmedStringArray (String key){
<span class="fc" id="L1584">    String[] a = getStringArray(key);</span>

<span class="fc bfc" id="L1586" title="All 2 branches covered.">    if (a != null) {</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">      for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L1588">        String s = a[i];</span>
<span class="pc bpc" id="L1589" title="2 of 4 branches missed.">        if (s != null &amp;&amp; s.length() &gt; 0) {</span>
<span class="fc" id="L1590">          a[i] = s.trim();</span>
        }
      }

<span class="fc" id="L1594">      return removeEmptyStrings(a);</span>

    } else {
<span class="fc" id="L1597">      return EMPTY_STRING_ARRAY;</span>
    }
  }

  public String[] getCompactStringArray(String key){
<span class="fc" id="L1602">    return removeEmptyStrings(getStringArray(key));</span>
  }

  
  public String[] getStringArray(String key, String[] def){
<span class="fc" id="L1607">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1608" title="1 of 4 branches missed.">    if (v != null &amp;&amp; (v.length() &gt; 0)) {</span>
<span class="fc" id="L1609">      return split(v);</span>
    } else {
<span class="fc" id="L1611">      return def;</span>
    }
  }

  public static String[] removeEmptyStrings (String[] a){
<span class="fc bfc" id="L1616" title="All 2 branches covered.">    if (a != null) {</span>
<span class="fc" id="L1617">      int n = 0;</span>
<span class="fc bfc" id="L1618" title="All 2 branches covered.">      for (int i=0; i&lt;a.length; i++){</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">        if (a[i].length() &gt; 0){</span>
<span class="fc" id="L1620">          n++;</span>
        }
      }

<span class="fc bfc" id="L1624" title="All 2 branches covered.">      if (n &lt; a.length){ // we have empty strings in the split</span>
<span class="fc" id="L1625">        String[] r = new String[n];</span>
<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">        for (int i=0, j=0; i&lt;a.length; i++){</span>
<span class="fc bfc" id="L1627" title="All 2 branches covered.">          if (a[i].length() &gt; 0){</span>
<span class="fc" id="L1628">            r[j++] = a[i];</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">            if (j == n){</span>
<span class="fc" id="L1630">              break;</span>
            }
          }
        }
<span class="fc" id="L1634">        return r;</span>

      } else {
<span class="fc" id="L1637">        return a;</span>
      }
    }

<span class="fc" id="L1641">    return null;</span>
  }


  /**
   * return an [optional] id part of a property value (all that follows the first '@')
   */
  String getIdPart (String key) {
<span class="fc" id="L1649">    String v = getProperty(key);</span>
<span class="pc bpc" id="L1650" title="1 of 4 branches missed.">    if ((v != null) &amp;&amp; (v.length() &gt; 0)) {</span>
<span class="fc" id="L1651">      int i = v.indexOf('@');</span>
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">      if (i &gt;= 0){</span>
<span class="nc" id="L1653">        return v.substring(i+1);</span>
      }
    }

<span class="fc" id="L1657">    return null;</span>
  }

  public Class&lt;?&gt; asClass (String v) throws JPFConfigException {
<span class="pc bpc" id="L1661" title="1 of 4 branches missed.">    if ((v != null) &amp;&amp; (v.length() &gt; 0)) {</span>
<span class="fc" id="L1662">      v = stripId(v);</span>
<span class="fc" id="L1663">      v = expandClassName(v);</span>
      try {
<span class="fc" id="L1665">        return loader.loadClass(v);</span>
<span class="fc" id="L1666">      } catch (ClassNotFoundException cfx) {</span>
<span class="fc" id="L1667">        throw new JPFConfigException(&quot;class not found &quot; + v + &quot; by classloader: &quot; + loader);</span>
<span class="nc" id="L1668">      } catch (ExceptionInInitializerError ix) {</span>
<span class="nc" id="L1669">        throw new JPFConfigException(&quot;class initialization of &quot; + v + &quot; failed: &quot; + ix,</span>
            ix);
      }
    }

<span class="fc" id="L1674">    return null;    </span>
  }
      
  public &lt;T&gt; Class&lt;? extends T&gt; getClass(String key, Class&lt;T&gt; type) throws JPFConfigException {
<span class="fc" id="L1678">    Class&lt;?&gt; cls = asClass( getProperty(key));</span>
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">    if (cls != null) {</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">      if (type.isAssignableFrom(cls)) {</span>
<span class="nc" id="L1681">        return cls.asSubclass(type);</span>
      } else {
<span class="nc" id="L1683">        throw new JPFConfigException(&quot;classname entry for: \&quot;&quot; + key + &quot;\&quot; not of type: &quot; + type.getName());</span>
      }
    }
<span class="fc" id="L1686">    return null;</span>
  }
  
    
  public Class&lt;?&gt; getClass(String key) throws JPFConfigException {
<span class="fc" id="L1691">    return asClass( getProperty(key));</span>
  }
  
  public Class&lt;?&gt; getEssentialClass(String key) throws JPFConfigException {
<span class="fc" id="L1695">    Class&lt;?&gt; cls = getClass(key);</span>
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">    if (cls == null) {</span>
<span class="nc" id="L1697">      throw new JPFConfigException(&quot;no classname entry for: \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
    }

<span class="fc" id="L1700">    return cls;</span>
  }
  
  String stripId (String v) {
<span class="fc" id="L1704">    int i = v.indexOf('@');</span>
<span class="pc bpc" id="L1705" title="1 of 2 branches missed.">    if (i &gt;= 0) {</span>
<span class="nc" id="L1706">      return v.substring(0,i);</span>
    } else {
<span class="fc" id="L1708">      return v;</span>
    }
  }

  String getId (String v){
<span class="nc" id="L1713">    int i = v.indexOf('@');</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">    if (i &gt;= 0) {</span>
<span class="nc" id="L1715">      return v.substring(i+1);</span>
    } else {
<span class="nc" id="L1717">      return null;</span>
    }
  }

  String expandClassName (String clsName) {
<span class="pc bpc" id="L1722" title="1 of 6 branches missed.">    if (clsName != null &amp;&amp; clsName.length() &gt; 0 &amp;&amp; clsName.charAt(0) == '.') {</span>
<span class="fc" id="L1723">      return &quot;gov.nasa.jpf&quot; + clsName;</span>
    } else {
<span class="fc" id="L1725">      return clsName;</span>
    }
  }

  
  public Class&lt;?&gt;[] getClasses(String key) throws JPFConfigException {
<span class="fc" id="L1731">    String[] v = getStringArray(key);</span>
<span class="fc bfc" id="L1732" title="All 2 branches covered.">    if (v != null) {</span>
<span class="fc" id="L1733">      int n = v.length;</span>
<span class="fc" id="L1734">      Class&lt;?&gt;[] a = new Class[n];</span>
<span class="fc bfc" id="L1735" title="All 2 branches covered.">      for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1736">        String clsName = expandClassName(v[i]);</span>
<span class="pc bpc" id="L1737" title="1 of 4 branches missed.">        if (clsName != null &amp;&amp; clsName.length() &gt; 0){</span>
          try {
<span class="fc" id="L1739">            clsName = stripId(clsName);</span>
<span class="fc" id="L1740">            a[i] = loader.loadClass(clsName);</span>
<span class="nc" id="L1741">          } catch (ClassNotFoundException cnfx) {</span>
<span class="nc" id="L1742">            throw new JPFConfigException(&quot;class not found &quot; + v[i]);</span>
<span class="nc" id="L1743">          } catch (ExceptionInInitializerError ix) {</span>
<span class="nc" id="L1744">            throw new JPFConfigException(&quot;class initialization of &quot; + v[i] + &quot; failed: &quot; + ix, ix);</span>
<span class="fc" id="L1745">          }</span>
        }
      }

<span class="fc" id="L1749">      return a;</span>
    }

<span class="fc" id="L1752">    return null;</span>
  }
  
  /**
   * this one is used to instantiate objects from a list of keys that share
   * the same prefix, e.g.
   * 
   *  shell.panels = config,site
   *  shell.panels.site = .shell.panels.SitePanel
   *  shell.panels.config = .shell.panels.ConfigPanel
   *  ...
   * 
   * note that we specify default class names, not classes, so that the classes
   * get loaded through our own loader at call time (they might not be visible
   * to our caller)
   */
  public &lt;T&gt; T[] getGroupInstances (String keyPrefix, String keyPostfix, Class&lt;T&gt; type, 
          String... defaultClsNames) throws JPFConfigException {
    
<span class="nc" id="L1771">    String[] ids = getCompactTrimmedStringArray(keyPrefix);</span>
    
<span class="nc bnc" id="L1773" title="All 2 branches missed.">    if (ids.length &gt; 0){</span>
<span class="nc" id="L1774">      keyPrefix = keyPrefix + '.';</span>
<span class="nc" id="L1775">      T[] arr = (T[]) Array.newInstance(type, ids.length);</span>
      
<span class="nc bnc" id="L1777" title="All 2 branches missed.">      for(int i = 0; i &lt; ids.length; i++){</span>
<span class="nc" id="L1778">        String key = keyPrefix + ids[i];</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">        if (keyPostfix != null){</span>
<span class="nc" id="L1780">          key = key + keyPostfix;</span>
        }
<span class="nc" id="L1782">        arr[i] = getEssentialInstance(key, type);</span>
      }
      
<span class="nc" id="L1785">      return arr;</span>
      
    } else {
<span class="nc" id="L1788">      T[] arr = (T[]) Array.newInstance(type, defaultClsNames.length);</span>
              
<span class="nc bnc" id="L1790" title="All 2 branches missed.">      for (int i=0; i&lt;arr.length; i++){</span>
<span class="nc" id="L1791">        arr[i] = getInstance((String)null, defaultClsNames[i], type);</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        if (arr[i] == null){</span>
<span class="nc" id="L1793">          exception(&quot;cannot instantiate default type &quot; + defaultClsNames[i]);</span>
        }
      }
      
<span class="nc" id="L1797">      return arr;</span>
    }
  }
  
  // &lt;2do&gt; - that's kind of kludged together, not very efficient
  String[] getIds (String key) {
<span class="fc" id="L1803">    String v = getProperty(key);</span>

<span class="pc bpc" id="L1805" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="fc" id="L1806">      int i = v.indexOf('@');</span>
<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">      if (i &gt;= 0) { // Ok, we have ids</span>
<span class="nc" id="L1808">        String[] a = split(v);</span>
<span class="nc" id="L1809">        String[] ids = new String[a.length];</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">        for (i = 0; i&lt;a.length; i++) {</span>
<span class="nc" id="L1811">          ids[i] = getId(a[i]);</span>
        }
<span class="nc" id="L1813">        return ids;</span>
      }
    }

<span class="fc" id="L1817">    return null;</span>
  }

  public &lt;T&gt; ArrayList&lt;T&gt; getInstances(String key, Class&lt;T&gt; type) throws JPFConfigException {

<span class="fc" id="L1822">    Class&lt;?&gt;[] argTypes = { Config.class };</span>
<span class="fc" id="L1823">    Object[] args = { this };</span>

<span class="fc" id="L1825">    return getInstances(key,type,argTypes,args);</span>
  }
  
  public &lt;T&gt; ArrayList&lt;T&gt; getInstances(String key, Class&lt;T&gt; type, Class&lt;?&gt;[]argTypes, Object[] args)
                                                      throws JPFConfigException {
<span class="fc" id="L1830">    Class&lt;?&gt;[] c = getClasses(key);</span>

<span class="fc bfc" id="L1832" title="All 2 branches covered.">    if (c != null) {</span>
<span class="fc" id="L1833">      String[] ids = getIds(key);</span>

<span class="fc" id="L1835">      ArrayList&lt;T&gt; a = new ArrayList&lt;T&gt;(c.length);</span>

<span class="fc bfc" id="L1837" title="All 2 branches covered.">      for (int i = 0; i &lt; c.length; i++) {</span>
<span class="pc bpc" id="L1838" title="1 of 2 branches missed.">        String id = (ids != null) ? ids[i] : null;</span>
<span class="fc" id="L1839">        T listener = getInstance(key, c[i], type, argTypes, args, id);</span>
<span class="fc bfc" id="L1840" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L1841">          a.add( listener);</span>
        } else {
          // should report here
        }
      }

<span class="fc" id="L1847">      return a;</span>
      
    } else {
      // should report here
    }

<span class="fc" id="L1853">    return null;</span>
  }
  
  public &lt;T&gt; T getInstance(String key, Class&lt;T&gt; type, String defClsName) throws JPFConfigException {
<span class="nc" id="L1857">    Class&lt;?&gt;[] argTypes = CONFIG_ARGTYPES;</span>
<span class="nc" id="L1858">    Object[] args = CONFIG_ARGS;</span>

<span class="nc" id="L1860">    Class&lt;?&gt; cls = getClass(key);</span>
<span class="nc" id="L1861">    String id = getIdPart(key);</span>

<span class="nc bnc" id="L1863" title="All 2 branches missed.">    if (cls == null) {</span>
      try {
<span class="nc" id="L1865">        cls = loader.loadClass(defClsName);</span>
<span class="nc" id="L1866">      } catch (ClassNotFoundException cfx) {</span>
<span class="nc" id="L1867">        throw new JPFConfigException(&quot;class not found &quot; + defClsName);</span>
<span class="nc" id="L1868">      } catch (ExceptionInInitializerError ix) {</span>
<span class="nc" id="L1869">        throw new JPFConfigException(&quot;class initialization of &quot; + defClsName + &quot; failed: &quot; + ix, ix);</span>
<span class="nc" id="L1870">      }</span>
    }
    
<span class="nc" id="L1873">    return getInstance(key, cls, type, argTypes, args, id);</span>
  }

  public &lt;T&gt; T getInstance(String key, Class&lt;T&gt; type) throws JPFConfigException {
<span class="fc" id="L1877">    Class&lt;?&gt;[] argTypes = CONFIG_ARGTYPES;</span>
<span class="fc" id="L1878">    Object[] args = CONFIG_ARGS;</span>

<span class="fc" id="L1880">    return getInstance(key, type, argTypes, args);</span>
  }
    
  public &lt;T&gt; T getInstance(String key, Class&lt;T&gt; type, Class&lt;?&gt;[] argTypes,
                            Object[] args) throws JPFConfigException {
<span class="fc" id="L1885">    Class&lt;?&gt; cls = getClass(key);</span>
<span class="fc" id="L1886">    String id = getIdPart(key);</span>

<span class="fc bfc" id="L1888" title="All 2 branches covered.">    if (cls != null) {</span>
<span class="fc" id="L1889">      return getInstance(key, cls, type, argTypes, args, id);</span>
    } else {
<span class="fc" id="L1891">      return null;</span>
    }
  }
  
  public &lt;T&gt; T getInstance(String key, Class&lt;T&gt; type, Object arg1, Object arg2)  throws JPFConfigException {
<span class="nc" id="L1896">    Class&lt;?&gt;[] argTypes = new Class&lt;?&gt;[2];</span>
<span class="nc" id="L1897">    argTypes[0] = arg1.getClass();</span>
<span class="nc" id="L1898">    argTypes[1] = arg2.getClass();</span>

<span class="nc" id="L1900">    Object[] args = new Object[2];</span>
<span class="nc" id="L1901">    args[0] = arg1;</span>
<span class="nc" id="L1902">    args[1] = arg2;</span>

<span class="nc" id="L1904">    return getInstance(key, type, argTypes, args);</span>
  }


  public &lt;T&gt; T getEssentialInstance(String key, Class&lt;T&gt; type) throws JPFConfigException {
<span class="fc" id="L1909">    Class&lt;?&gt;[] argTypes = { Config.class };</span>
<span class="fc" id="L1910">    Object[] args = { this };</span>
<span class="fc" id="L1911">    return getEssentialInstance(key, type, argTypes, args);</span>
  }

  /**
   * just a convenience method for ctor calls that take two arguments
   */
  public &lt;T&gt; T getEssentialInstance(String key, Class&lt;T&gt; type, Object arg1, Object arg2)  throws JPFConfigException {
<span class="nc" id="L1918">    Class&lt;?&gt;[] argTypes = new Class&lt;?&gt;[2];</span>
<span class="nc" id="L1919">    argTypes[0] = arg1.getClass();</span>
<span class="nc" id="L1920">    argTypes[1] = arg2.getClass();</span>

<span class="nc" id="L1922">    Object[] args = new Object[2];</span>
<span class="nc" id="L1923">    args[0] = arg1;</span>
<span class="nc" id="L1924">    args[1] = arg2;</span>

<span class="nc" id="L1926">    return getEssentialInstance(key, type, argTypes, args);</span>
  }

  public &lt;T&gt; T getEssentialInstance(String key, Class&lt;T&gt; type, Class&lt;?&gt;[] argTypes, Object[] args) throws JPFConfigException {
<span class="fc" id="L1930">    Class&lt;?&gt; cls = getEssentialClass(key);</span>
<span class="fc" id="L1931">    String id = getIdPart(key);</span>

<span class="fc" id="L1933">    return getInstance(key, cls, type, argTypes, args, id);</span>
  }

  public &lt;T&gt; T getInstance (String id, String clsName, Class&lt;T&gt; type, Class&lt;?&gt;[] argTypes, Object[] args) throws JPFConfigException {
<span class="fc" id="L1937">    Class&lt;?&gt; cls = asClass(clsName);</span>
    
<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">    if (cls != null) {</span>
<span class="fc" id="L1940">      return getInstance(id, cls, type, argTypes, args, id);</span>
    } else {
<span class="nc" id="L1942">      return null;</span>
    }
  }
  
  public &lt;T&gt; T getInstance (String id, String clsName, Class&lt;T&gt; type) throws JPFConfigException {
<span class="nc" id="L1947">    Class&lt;?&gt;[] argTypes = CONFIG_ARGTYPES;</span>
<span class="nc" id="L1948">    Object[] args = CONFIG_ARGS;</span>

<span class="nc" id="L1950">    Class&lt;?&gt; cls = asClass(clsName);</span>
    
<span class="nc bnc" id="L1952" title="All 2 branches missed.">    if (cls != null) {</span>
<span class="nc" id="L1953">      return getInstance(id, cls, type, argTypes, args, id);</span>
    } else {
<span class="nc" id="L1955">      return null;</span>
    }
  }
  
  /**
   * this is our private instantiation workhorse - try to instantiate an object of
   * class 'cls' by using the following ordered set of ctors 1. &lt;cls&gt;(
   * &lt;argTypes&gt;) 2. &lt;cls&gt;(Config) 3. &lt;cls&gt;() if all of that fails, or there was
   * a 'type' provided the instantiated object does not comply with, return null
   */
  &lt;T&gt; T getInstance(String key, Class&lt;?&gt; cls, Class&lt;T&gt; type, Class&lt;?&gt;[] argTypes,
                     Object[] args, String id) throws JPFConfigException {
<span class="fc" id="L1967">    Object o = null;</span>
<span class="fc" id="L1968">    Constructor&lt;?&gt; ctor = null;</span>

<span class="fc bfc" id="L1970" title="All 2 branches covered.">    if (cls == null) {</span>
<span class="fc" id="L1971">      return null;</span>
    }

<span class="fc bfc" id="L1974" title="All 2 branches covered.">    if (id != null) { // check first if we already have this one instantiated as a singleton</span>
<span class="fc bfc" id="L1975" title="All 2 branches covered.">      if (singletons == null) {</span>
<span class="fc" id="L1976">        singletons = new HashMap&lt;String,Object&gt;();</span>
      } else {
<span class="fc" id="L1978">        o = type.cast(singletons.get(id));</span>
      }
    }

<span class="fc bfc" id="L1982" title="All 2 branches covered.">    while (o == null) {</span>
      try {
<span class="fc" id="L1984">        ctor = cls.getConstructor(argTypes);</span>
<span class="fc" id="L1985">        o = ctor.newInstance(args);</span>
<span class="fc" id="L1986">      } catch (NoSuchMethodException nmx) {</span>
         
<span class="pc bpc" id="L1988" title="2 of 6 branches missed.">        if ((argTypes.length &gt; 1) || ((argTypes.length == 1) &amp;&amp; (argTypes[0] != Config.class))) {</span>
          // fallback 1: try a single Config param
<span class="fc" id="L1990">          argTypes = CONFIG_ARGTYPES;</span>
<span class="fc" id="L1991">          args = CONFIG_ARGS;</span>

<span class="pc bpc" id="L1993" title="1 of 2 branches missed.">        } else if (argTypes.length &gt; 0) {</span>
          // fallback 2: try the default ctor
<span class="fc" id="L1995">          argTypes = NO_ARGTYPES;</span>
<span class="fc" id="L1996">          args = NO_ARGS;</span>

        } else {
          // Ok, there is no suitable ctor, bail out
<span class="nc" id="L2000">          throw new JPFConfigException(key, cls, &quot;no suitable ctor found&quot;);</span>
        }
<span class="nc" id="L2002">      } catch (IllegalAccessException iacc) {</span>
<span class="nc" id="L2003">        throw new JPFConfigException(key, cls, &quot;\n&gt; ctor not accessible: &quot;</span>
<span class="nc" id="L2004">            + getMethodSignature(ctor));</span>
<span class="nc" id="L2005">      } catch (IllegalArgumentException iarg) {</span>
<span class="nc" id="L2006">        throw new JPFConfigException(key, cls, &quot;\n&gt; illegal constructor arguments: &quot;</span>
<span class="nc" id="L2007">            + getMethodSignature(ctor));</span>
<span class="nc" id="L2008">      } catch (InvocationTargetException ix) {</span>
<span class="nc" id="L2009">        Throwable tx = ix.getTargetException();</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">        if (tx instanceof JPFConfigException) {</span>
<span class="nc" id="L2011">          throw new JPFConfigException(tx.getMessage() + &quot;\n&gt; used within \&quot;&quot; + key</span>
              + &quot;\&quot; instantiation of &quot; + cls);
        } else {
<span class="nc" id="L2014">          throw new JPFConfigException(key, cls, &quot;\n&gt; exception in &quot;</span>
<span class="nc" id="L2015">              + getMethodSignature(ctor) + &quot;:\n&gt;&gt; &quot; + tx, tx);</span>
        }
<span class="nc" id="L2017">      } catch (InstantiationException ivt) {</span>
<span class="nc" id="L2018">        throw new JPFConfigException(key, cls,</span>
            &quot;\n&gt; abstract class cannot be instantiated&quot;);
<span class="nc" id="L2020">      } catch (ExceptionInInitializerError eie) {</span>
<span class="nc" id="L2021">        throw new JPFConfigException(key, cls, &quot;\n&gt; static initialization failed:\n&gt;&gt; &quot;</span>
<span class="nc" id="L2022">            + eie.getException(), eie.getException());</span>
<span class="fc" id="L2023">      }</span>
    }

    // check type
<span class="pc bpc" id="L2027" title="1 of 2 branches missed.">    if (!type.isInstance(o)) {</span>
<span class="nc" id="L2028">      throw new JPFConfigException(key, cls, &quot;\n&gt; instance not of type: &quot;</span>
<span class="nc" id="L2029">          + type.getName());</span>
    }

<span class="fc bfc" id="L2032" title="All 2 branches covered.">    if (id != null) { // add to singletons (in case it's not already in there)</span>
<span class="fc" id="L2033">      singletons.put(id, o);</span>
    }

<span class="fc" id="L2036">    return type.cast(o); // safe according to above</span>
  }

  public String getMethodSignature(Constructor&lt;?&gt; ctor) {
<span class="nc" id="L2040">    StringBuilder sb = new StringBuilder(ctor.getName());</span>
<span class="nc" id="L2041">    sb.append('(');</span>
<span class="nc" id="L2042">    Class&lt;?&gt;[] argTypes = ctor.getParameterTypes();</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">    for (int i = 0; i &lt; argTypes.length; i++) {</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">      if (i &gt; 0) {</span>
<span class="nc" id="L2045">        sb.append(',');</span>
      }
<span class="nc" id="L2047">      sb.append(argTypes[i].getName());</span>
    }
<span class="nc" id="L2049">    sb.append(')');</span>
<span class="nc" id="L2050">    return sb.toString();</span>
  }

  public boolean hasValue(String key) {
<span class="nc" id="L2054">    String v = getProperty(key);</span>
<span class="nc bnc" id="L2055" title="All 4 branches missed.">    return ((v != null) &amp;&amp; (v.length() &gt; 0));</span>
  }

  public boolean hasValueIgnoreCase(String key, String value) {
<span class="nc" id="L2059">    String v = getProperty(key);</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L2061">      return v.equalsIgnoreCase(value);</span>
    }

<span class="nc" id="L2064">    return false;</span>
  }

  public int getChoiceIndexIgnoreCase(String key, String[] choices) {
<span class="nc" id="L2068">    String v = getProperty(key);</span>

<span class="nc bnc" id="L2070" title="All 4 branches missed.">    if ((v != null) &amp;&amp; (choices != null)) {</span>
<span class="nc bnc" id="L2071" title="All 2 branches missed.">      for (int i = 0; i &lt; choices.length; i++) {</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">        if (v.equalsIgnoreCase(choices[i])) {</span>
<span class="nc" id="L2073">          return i;</span>
        }
      }
    }

<span class="nc" id="L2078">    return -1;</span>
  }

  public URL getURL (String key){
<span class="nc" id="L2082">    String v = getProperty(key);</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">    if (v != null) {</span>
      try {
<span class="nc" id="L2085">        return FileUtils.getURL(v);</span>
<span class="nc" id="L2086">      } catch (Throwable x){</span>
<span class="nc" id="L2087">        throw exception(&quot;malformed URL: &quot; + v);</span>
      }
    } else {
<span class="nc" id="L2090">      return null;</span>
    }
  }

  public File[] getPathArray (String key) {    
<span class="fc" id="L2095">    String v = getProperty(key);</span>
<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">    if (v != null) {</span>
<span class="fc" id="L2097">      String[] pe = removeEmptyStrings( pathSplit(v));</span>
      
<span class="pc bpc" id="L2099" title="2 of 4 branches missed.">      if (pe != null &amp;&amp; pe.length &gt; 0) {</span>
<span class="fc" id="L2100">        File[] files = new File[pe.length];</span>
<span class="fc bfc" id="L2101" title="All 2 branches covered.">        for (int i=0; i&lt;files.length; i++) {</span>
<span class="fc" id="L2102">          String path = FileUtils.asPlatformPath(pe[i]);</span>
<span class="fc" id="L2103">          files[i] = new File(path);</span>
        }
<span class="fc" id="L2105">        return files;</span>
      }      
    }

<span class="nc" id="L2109">    return new File[0];</span>
  }

  public File getPath (String key) {
<span class="nc" id="L2113">    String v = getProperty(key);</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L2115">      return new File(FileUtils.asPlatformPath(v));</span>
    }
    
<span class="nc" id="L2118">    return null;</span>
  }

<span class="fc" id="L2121">  static final char[] UNIX_PATH_SEPARATORS = {',', ';', ':' };</span>
<span class="fc" id="L2122">  static final char[] WINDOWS_PATH_SEPARATORS = {',', ';' };</span>

  protected String[] pathSplit (String input){
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">    if (File.pathSeparatorChar == ':'){</span>
<span class="fc" id="L2126">      return split( input, UNIX_PATH_SEPARATORS);</span>
    } else {
<span class="nc" id="L2128">      return split( input, WINDOWS_PATH_SEPARATORS);</span>
    }
  }

<span class="fc" id="L2132">  static final char[] DELIMS = { ',', ';' };</span>

  /**
   * our own version of split, which handles &quot;`&quot; quoting, and breaks on non-quoted
   * ',' and ';' chars. We need this so that we can use ';' separated lists in
   * JPF property files, but still can use quoted ';' if we absolutely have to
   * specify Java signatures. On the other hand, we can't quote with '\' because
   * that would make Windows paths even more terrible.
   * regexes are bad at quoting, and this is more efficient anyways
   */
  protected String[] split (String input){
<span class="fc" id="L2143">    return split(input, DELIMS);</span>
  }

  private boolean isDelim(char[] delim, char c){
<span class="fc bfc" id="L2147" title="All 2 branches covered.">    for (int i=0; i&lt;delim.length; i++){</span>
<span class="fc bfc" id="L2148" title="All 2 branches covered.">      if (c == delim[i]){</span>
<span class="fc" id="L2149">        return true;</span>
      }
    }
<span class="fc" id="L2152">    return false;</span>
  }

  protected String[] split (String input, char[] delim){
<span class="fc" id="L2156">    int n = input.length();</span>
<span class="fc" id="L2157">    ArrayList&lt;String&gt; elements = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2158">    boolean quote = false;</span>

<span class="fc" id="L2160">    char[] buf = new char[128];</span>
<span class="fc" id="L2161">    int k=0;</span>

<span class="fc bfc" id="L2163" title="All 2 branches covered.">    for (int i=0; i&lt;n; i++){</span>
<span class="fc" id="L2164">      char c = input.charAt(i);</span>

<span class="pc bpc" id="L2166" title="1 of 2 branches missed.">      if (!quote) {</span>
<span class="fc bfc" id="L2167" title="All 2 branches covered.">        if (isDelim(delim,c)){ // element separator</span>
<span class="fc" id="L2168">          elements.add( new String(buf, 0, k));</span>
<span class="fc" id="L2169">          k = 0;</span>
<span class="fc" id="L2170">          continue;</span>
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">        } else if (c=='`') {</span>
<span class="nc" id="L2172">          quote = true;</span>
<span class="nc" id="L2173">          continue;</span>
        }
      }

<span class="fc bfc" id="L2177" title="All 2 branches covered.">      if (k &gt;= buf.length){</span>
<span class="fc" id="L2178">        char[] newBuf = new char[buf.length+128];</span>
<span class="fc" id="L2179">        System.arraycopy(buf, 0, newBuf, 0, k);</span>
<span class="fc" id="L2180">        buf = newBuf;</span>
      }
<span class="fc" id="L2182">      buf[k++] = c;</span>
<span class="fc" id="L2183">      quote = false;</span>
    }

<span class="fc bfc" id="L2186" title="All 2 branches covered.">    if (k&gt;0){</span>
<span class="fc" id="L2187">      elements.add( new String(buf, 0, k));</span>
    }

<span class="fc" id="L2190">    return elements.toArray(new String[elements.size()]);</span>
  }

  static final String UNINITIALIZED = &quot;uninitialized&quot;;
  // this is where we store the initial values in case we have to recollect
<span class="pc" id="L2195">  String initialNativeClasspath = UNINITIALIZED, </span>
          initialClasspath = UNINITIALIZED, 
          initialSourcepath = UNINITIALIZED, 
          initialPeerPackages = UNINITIALIZED,
          initialNativeLibraries = UNINITIALIZED;
  

  /**
   * this resets to what was explicitly set in the config files
   */
  public void resetGlobalPaths() {
<span class="nc bnc" id="L2206" title="All 2 branches missed.">    if (initialNativeClasspath == UNINITIALIZED){</span>
<span class="nc" id="L2207">      initialNativeClasspath = getString(&quot;native_classpath&quot;);</span>
    } else {
<span class="nc" id="L2209">      put0( &quot;native_classpath&quot;, initialNativeClasspath);</span>
    }

<span class="nc bnc" id="L2212" title="All 2 branches missed.">    if (initialClasspath == UNINITIALIZED){</span>
<span class="nc" id="L2213">      initialClasspath = getString(&quot;classpath&quot;);</span>
    } else {
<span class="nc" id="L2215">      put0( &quot;classpath&quot;, initialClasspath);</span>
    }
    
<span class="nc bnc" id="L2218" title="All 2 branches missed.">    if (initialSourcepath == UNINITIALIZED){</span>
<span class="nc" id="L2219">      initialSourcepath = getString(&quot;sourcepath&quot;);</span>
    } else {
<span class="nc" id="L2221">      put0( &quot;sourcepath&quot;, initialSourcepath);</span>
    }

<span class="nc bnc" id="L2224" title="All 2 branches missed.">    if (initialPeerPackages == UNINITIALIZED){</span>
<span class="nc" id="L2225">      initialPeerPackages = getString(&quot;peer_packages&quot;);</span>
    } else {
<span class="nc" id="L2227">      put0( &quot;peer_packages&quot;, initialPeerPackages);</span>
    }

<span class="nc bnc" id="L2230" title="All 2 branches missed.">    if (initialNativeLibraries == UNINITIALIZED){</span>
<span class="nc" id="L2231">      initialNativeLibraries = getString(&quot;native_libraries&quot;);</span>
    } else {
<span class="nc" id="L2233">      put0( &quot;native_libraries&quot;, initialNativeLibraries);</span>
    }
<span class="nc" id="L2235">  }</span>

  /**
   * collect all the &lt;project&gt;.{native_classpath,classpath,sourcepath,peer_packages,native_libraries}
   * and append them to the global settings
   *
   * NOTE - this is now called from within initClassLoader, which should only happen once and
   * is the first time we really need the global paths.
   *
   * &lt;2do&gt; this is Ok for native_classpath and native_libraries, but we should probably do
   * classpath, sourcepath and peer_packages separately (they can be collected later)
   */
  public void collectGlobalPaths() {
        
    // note - this is in the order of entry, i.e. reflects priorities
    // we have to process this in reverse order so that later entries are prioritized
<span class="fc" id="L2251">    String[] keys = getEntrySequence();</span>

<span class="fc" id="L2253">    String nativeLibKey = &quot;.&quot; + System.getProperty(&quot;os.name&quot;) +</span>
<span class="fc" id="L2254">            '.' + System.getProperty(&quot;os.arch&quot;) + &quot;.native_libraries&quot;;</span>

<span class="fc bfc" id="L2256" title="All 2 branches covered.">    for (int i = keys.length-1; i&gt;=0; i--){</span>
<span class="fc" id="L2257">      String k = keys[i];</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">      if (k.endsWith(&quot;.native_classpath&quot;)){</span>
<span class="fc" id="L2259">        appendPath(&quot;native_classpath&quot;, k);</span>
        
<span class="fc bfc" id="L2261" title="All 2 branches covered.">      } else if (k.endsWith(&quot;.classpath&quot;)){</span>
<span class="fc" id="L2262">        appendPath(&quot;classpath&quot;, k);</span>
        
<span class="fc bfc" id="L2264" title="All 2 branches covered.">      } else if (k.endsWith(&quot;.sourcepath&quot;)){        </span>
<span class="fc" id="L2265">        appendPath(&quot;sourcepath&quot;, k);</span>
        
<span class="fc bfc" id="L2267" title="All 2 branches covered.">      } else if (k.endsWith(&quot;peer_packages&quot;)){</span>
<span class="fc" id="L2268">        append(&quot;peer_packages&quot;, getString(k), &quot;,&quot;);</span>
        
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">      } else if (k.endsWith(nativeLibKey)){</span>
<span class="nc" id="L2271">        appendPath(&quot;native_libraries&quot;, k);</span>
      }
    }
<span class="fc" id="L2274">  }</span>

  
<span class="fc" id="L2277">  static Pattern absPath = Pattern.compile(&quot;(?:[a-zA-Z]:)?[/\\\\].*&quot;);</span>

  void appendPath (String pathKey, String key){
<span class="fc" id="L2280">    String projName = key.substring(0, key.indexOf('.'));</span>
<span class="fc" id="L2281">    String pathPrefix = null;</span>

<span class="pc bpc" id="L2283" title="1 of 2 branches missed.">    if (projName.isEmpty()){</span>
<span class="nc" id="L2284">      pathPrefix = new File(&quot;.&quot;).getAbsolutePath();</span>
    } else {
<span class="fc" id="L2286">      pathPrefix = getString(projName);</span>
    }

<span class="pc bpc" id="L2289" title="1 of 2 branches missed.">    if (pathPrefix != null){</span>
<span class="fc" id="L2290">      pathPrefix += '/';</span>

<span class="fc" id="L2292">      String[] elements = getCompactStringArray(key);</span>
<span class="pc bpc" id="L2293" title="1 of 2 branches missed.">      if (elements != null){</span>
<span class="fc bfc" id="L2294" title="All 2 branches covered.">        for (String e : elements) {</span>
<span class="pc bpc" id="L2295" title="2 of 4 branches missed.">          if (e != null &amp;&amp; e.length()&gt;0){</span>

            // if this entry is not an absolute path, or doesn't start with
            // the project path, prepend the project path
<span class="pc bpc" id="L2299" title="3 of 4 branches missed.">            if (!(absPath.matcher(e).matches()) &amp;&amp; !e.startsWith(pathPrefix)) {</span>
<span class="nc" id="L2300">              e = pathPrefix + e;</span>
            }

<span class="fc" id="L2303">            append(pathKey, e);</span>
          }
        }
      }

    } else {
      //throw new JPFConfigException(&quot;no project path for &quot; + key);
    }
<span class="fc" id="L2311">  }</span>


  //--- our modification interface

  /**
   * iterate over all keys, if a key starts with the provided keyPrefix, add
   * this value under the corresponding key suffix. For example:
   *
   *  test.report.console.finished = result
   *
   *    -&gt; prompotePropertyCategory(&quot;test.&quot;) -&gt;
   *
   *  report.console.finished = result
   *
   * if a matching key has an IGNORE_VALUE value (&quot;-&quot;), the entry is *not* promoted
   * (we need this to override promoted keys)
   */
  public void promotePropertyCategory (String keyPrefix){
<span class="fc" id="L2330">    int prefixLen = keyPrefix.length();</span>
    
    // HashTable does not support adding elements while iterating over the entrySet 
<span class="fc" id="L2333">    ArrayList&lt;Map.Entry&lt;Object,Object&gt;&gt; promoted = null;</span>
    
<span class="fc bfc" id="L2335" title="All 2 branches covered.">    for (Map.Entry&lt;Object,Object&gt; e : entrySet()){</span>
<span class="fc" id="L2336">      Object k = e.getKey();</span>
<span class="pc bpc" id="L2337" title="1 of 2 branches missed.">      if (k instanceof String){</span>
<span class="fc" id="L2338">        String key = (String)k;</span>
<span class="fc bfc" id="L2339" title="All 2 branches covered.">        if (key.startsWith(keyPrefix)){</span>
<span class="fc" id="L2340">          Object v = e.getValue();</span>
<span class="pc bpc" id="L2341" title="1 of 2 branches missed.">          if (! IGNORE_VALUE.equals(v)){</span>
<span class="pc bpc" id="L2342" title="1 of 2 branches missed.">            if (promoted == null){</span>
<span class="fc" id="L2343">              promoted = new ArrayList&lt;Map.Entry&lt;Object,Object&gt;&gt;();</span>
            }
<span class="fc" id="L2345">            promoted.add(e);</span>
          }
        }
      }
<span class="fc" id="L2349">    }</span>
    
<span class="pc bpc" id="L2351" title="1 of 2 branches missed.">    if (promoted != null){</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">      for (Map.Entry&lt;Object, Object&gt; e : promoted) {</span>
<span class="fc" id="L2353">        String key = (String) e.getKey();</span>
<span class="fc" id="L2354">        key = key.substring(prefixLen);</span>

<span class="fc" id="L2356">        put(key, e.getValue());</span>
<span class="fc" id="L2357">      }</span>
    }
<span class="fc" id="L2359">  }</span>

  
  @Override
  public Object setProperty (String key, String newValue) {    
<span class="fc" id="L2364">    Object oldValue = put(key, newValue);    </span>
<span class="fc" id="L2365">    notifyPropertyChangeListeners(key, (String)oldValue, newValue);</span>
<span class="fc" id="L2366">    return oldValue;</span>
  }

  public void parse (String s) {
    
<span class="fc" id="L2371">    int i = s.indexOf(&quot;=&quot;);</span>
<span class="pc bpc" id="L2372" title="1 of 2 branches missed.">    if (i &gt; 0) {</span>
      String key, val;
      
<span class="pc bpc" id="L2375" title="2 of 4 branches missed.">      if (i &gt; 1 &amp;&amp; s.charAt(i-1)=='+') { // append</span>
<span class="nc" id="L2376">        key = s.substring(0, i-1).trim();</span>
<span class="nc" id="L2377">        val = s.substring(i+1); // it's going to be normalized anyways</span>
<span class="nc" id="L2378">        append(key, val);</span>
        
      } else { // put
<span class="fc" id="L2381">        key = s.substring(0, i).trim();</span>
<span class="fc" id="L2382">        val = s.substring(i+1);</span>
<span class="fc" id="L2383">        setProperty(key, val);</span>
      }
      
    }
<span class="fc" id="L2387">  }</span>
  
  protected void notifyPropertyChangeListeners (String key, String oldValue, String newValue) {
<span class="fc bfc" id="L2390" title="All 2 branches covered.">    if (changeListeners != null) {</span>
<span class="fc bfc" id="L2391" title="All 2 branches covered.">      for (ConfigChangeListener l : changeListeners) {</span>
<span class="fc" id="L2392">        l.propertyChanged(this, key, oldValue, newValue);</span>
<span class="fc" id="L2393">      }</span>
    }    
<span class="fc" id="L2395">  }</span>
  
  public String[] asStringArray (String s){
<span class="fc" id="L2398">    return split(s);</span>
  }
  
  public TreeMap&lt;Object,Object&gt; asOrderedMap() {
<span class="nc" id="L2402">    TreeMap&lt;Object,Object&gt; map = new TreeMap&lt;Object,Object&gt;();</span>
<span class="nc" id="L2403">    map.putAll(this);</span>
<span class="nc" id="L2404">    return map;</span>
  }
  
  //--- various debugging methods

  public void print (PrintWriter pw) {
<span class="fc" id="L2410">    pw.println(&quot;----------- Config contents&quot;);</span>

    // just how much do you have to do to get a printout with keys in alphabetical order :&lt;
<span class="fc" id="L2413">    TreeSet&lt;String&gt; kset = new TreeSet&lt;String&gt;();</span>
<span class="fc bfc" id="L2414" title="All 2 branches covered.">    for (Enumeration&lt;?&gt; e = propertyNames(); e.hasMoreElements();) {</span>
<span class="fc" id="L2415">      Object k = e.nextElement();</span>
<span class="pc bpc" id="L2416" title="1 of 2 branches missed.">      if (k instanceof String) {</span>
<span class="fc" id="L2417">        kset.add( (String)k);</span>
      }
<span class="fc" id="L2419">    }</span>

<span class="fc bfc" id="L2421" title="All 2 branches covered.">    for (String key : kset) {</span>
<span class="fc" id="L2422">      String val = getProperty(key);</span>
<span class="fc" id="L2423">      pw.print(key);</span>
<span class="fc" id="L2424">      pw.print(&quot; = &quot;);</span>
<span class="fc" id="L2425">      pw.println(val);</span>
<span class="fc" id="L2426">    }</span>

<span class="fc" id="L2428">    pw.flush();</span>
<span class="fc" id="L2429">  }</span>

  public void printSources (PrintWriter pw) {
<span class="nc" id="L2432">    pw.println(&quot;----------- Config sources&quot;);</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">    for (Object src : sources){</span>
<span class="nc" id="L2434">      pw.println(src);</span>
<span class="nc" id="L2435">    }    </span>
<span class="nc" id="L2436">  }</span>
  
  public void printEntries() {
<span class="fc" id="L2439">    PrintWriter pw = new PrintWriter(System.out);</span>
<span class="fc" id="L2440">    print(pw);</span>
<span class="fc" id="L2441">  }</span>

  public String getSourceName (Object src){
<span class="nc bnc" id="L2444" title="All 2 branches missed.">    if (src instanceof File){</span>
<span class="nc" id="L2445">      return ((File)src).getAbsolutePath();</span>
<span class="nc bnc" id="L2446" title="All 2 branches missed.">    } else if (src instanceof URL){</span>
<span class="nc" id="L2447">      return ((URL)src).toString();</span>
    } else {
<span class="nc" id="L2449">      return src.toString();</span>
    }
  }
  
  public List&lt;Object&gt; getSources() {
<span class="nc" id="L2454">    return sources;</span>
  }
  
  public void printStatus(Logger log) {
<span class="nc" id="L2458">    int idx = 0;</span>
    
<span class="nc bnc" id="L2460" title="All 2 branches missed.">    for (Object src : sources){</span>
<span class="nc bnc" id="L2461" title="All 2 branches missed.">      if (src instanceof File){</span>
<span class="nc" id="L2462">        log.config(&quot;configuration source &quot; + idx++ + &quot; : &quot; + getSourceName(src));</span>
      }
<span class="nc" id="L2464">    }</span>
<span class="nc" id="L2465">  }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>